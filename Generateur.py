# -*- coding: utf-8 -*-
"""G√©n√©rateur_complet_de_Menus_2.3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19OBFkinvdPXJy3omyKx6Al_hOVsdwGog

**Charger fichier Planning.csv**
"""

# @title
from IPython.display import display, HTML

# Affichage d'un message visuel bien visible
display(HTML("""
    <div style="border:2px solid #1976D2; border-radius:8px; padding:16px; background:#E3F2FD; margin-bottom:10px;">
        <h3 style="color:#1976D2; margin:0;">
            üìÑ Veuillez charger le fichier <b>Planning.csv</b> (ou tout fichier contenant "planning" dans le nom) en cliquant sur <u>Choisir des fichiers</u> ci-dessous.
        </h3>
        <p style="color:#333;">Le traitement ne pourra pas continuer sans ce fichier.</p>
    </div>
"""))

try:
    from google.colab import files
    uploaded = files.upload()
except ImportError:
    print("‚ö†Ô∏è Ce code doit √™tre ex√©cut√© dans Google Colab.")

import pandas as pd

# Recherche du fichier planning (insensible √† la casse)
planning_file = None
for fname in uploaded.keys():
    if 'planning' in fname.lower():
        planning_file = fname
        break

if planning_file is not None:
    print(f"‚úÖ Fichier {planning_file} charg√© avec succ√®s !")
    # D√©tection automatique du s√©parateur CSV
    df_planning = pd.read_csv(planning_file, sep=None, engine='python')
    print(df_planning.head())
else:
    print("‚ùå Aucun fichier contenant 'planning' n'a √©t√© charg√©. Veuillez r√©ex√©cuter la cellule et charger le bon fichier.")
    raise RuntimeError("Fichier Planning.csv manquant.")


"""API Ingr√©dients"""

# @title
import csv
from notion_client import Client
from notion_client.errors import RequestTimeoutError
import time
import httpx
import logging

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- PARAM√àTRES NOTION ---
notion = Client(auth="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")
database_id = "b23b048b67334032ac1ae4e82d308817"
csv_filename = "Ingredients.csv"
num_rows_to_extract = 1000  # Limite pour les tests, modifiable

batch_size = 25
api_timeout_seconds = 180
max_retries = 7

total_extracted = 0
next_cursor = None

def extract_property_value(prop):
    if not isinstance(prop, dict):
        return ""
    t = prop.get("type")
    if t == "title":
        return "".join([t.get("plain_text", "") for t in prop.get("title", [])])
    elif t == "rich_text":
        return "".join([t.get("plain_text", "") for t in prop.get("rich_text", [])])
    elif t == "multi_select":
        return ", ".join([opt.get("name", "") for opt in prop.get("multi_select", [])])
    elif t == "select":
        select_obj = prop.get("select")
        if select_obj is not None:
            return select_obj.get("name", "")
        return ""
    elif t == "number":
        return str(prop.get("number", ""))
    elif t == "checkbox":
        return str(prop.get("checkbox", ""))
    elif t == "date":
        date_obj = prop.get("date")
        if date_obj is not None:
            return date_obj.get("start", "")
        return ""
    elif t == "people":
        return ", ".join([person.get("name", "") for person in prop.get("people", [])])
    elif t == "relation":
        return ", ".join([rel.get("id", "") for rel in prop.get("relation", [])])
    elif t == "url":
        return prop.get("url", "")
    elif t == "email":
        return prop.get("email", "")
    elif t == "phone_number":
        return prop.get("phone_number", "")
    elif t == "formula":
        formula = prop.get("formula", {})
        if formula.get("type") == "string":
            return formula.get("string", "")
        elif formula.get("type") == "number":
            return str(formula.get("number", ""))
        elif formula.get("type") == "boolean":
            return str(formula.get("boolean", ""))
    elif t == "rollup":
        rollup = prop.get("rollup", {})
        if rollup.get("type") == "array":
            return ", ".join([
                str(item.get("plain_text", ""))
                for item in rollup.get("array", [])
            ])
        elif rollup.get("type") in ["number", "string"]:
            return str(rollup.get(rollup.get("type"), ""))
    return ""

try:
    with open(csv_filename, 'w', newline='', encoding='utf-8') as csvfile:
        csv_writer = None
        while total_extracted < num_rows_to_extract:
            try:
                results = notion.databases.query(
                    database_id=database_id,
                    start_cursor=next_cursor,
                    page_size=batch_size,
                    timeout=api_timeout_seconds,
                    filter={
                        "property": "Type de stock",
                        "select": {"equals": "Autre type"}
                    }
                )
                page_results = results.get("results", [])
                if not page_results:
                    logger.info("Aucun r√©sultat retourn√© par l'API ou fin de la base de donn√©es atteinte.")
                    break

                for result in page_results:
                    if total_extracted >= num_rows_to_extract:
                        break
                    properties = result.get("properties", {})
                    if csv_writer is None:
                        # D√©terminer dynamiquement les colonnes √† partir des propri√©t√©s de la premi√®re ligne
                        # D√©finis ici les colonnes √† inclure, dans l‚Äôordre souhait√©
                        header = ["Page_ID", "Nom", "Type de stock", "unit√©", "Qte reste"]
                        csv_writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL, dialect='excel')
                        csv_writer.writerow(header)

                        for result in page_results:
                            properties = result.get("properties", {})
                            row_values = [result.get("id", "")]
                            # Pour chaque colonne, extrais la valeur correspondante
                            row_values.append(extract_property_value(properties.get("Nom", {})))
                            row_values.append(extract_property_value(properties.get("Type de stock", {})))
                            row_values.append(extract_property_value(properties.get("unit√©", {})))
                            row_values.append(extract_property_value(properties.get("Qte reste", {})))
                            csv_writer.writerow(row_values)


                    row_values = [result.get("id", "")]
                    row_values += [extract_property_value(properties[prop_name]) for prop_name in header[1:]]
                    csv_writer.writerow(row_values)

                    total_extracted += 1

                next_cursor = results.get("next_cursor")
                if not next_cursor:
                    break
                time.sleep(1)
            except (httpx.TimeoutException, RequestTimeoutError) as e:
                logger.warning(f"Timeout d√©tect√© : {e}")
                time.sleep(10)
                continue
            except Exception as e:
                logger.exception(f"Erreur inattendue : {e}")
                break
    logger.info(f"Extraction termin√©e. {total_extracted} lignes export√©es dans {csv_filename}.")
except IOError as e:
    logger.error(f"Erreur d'√©criture du fichier : {e}")

"""API Ingr√©dients_Recettes"""

# @title
import csv
from notion_client import Client
import time

# --- PARAM√àTRES NOTION ---
notion = Client(auth="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")
database_id = "1d16fa46f8b2805b8377eba7bf668eb5"
csv_filename = "Ingredients_recettes.csv"
num_rows_to_extract = 2000  # Extraction de 2000 lignes max

batch_size = 25
api_timeout_seconds = 180

total_extracted = 0
next_cursor = None

def extract_property_value(prop):
    if not isinstance(prop, dict):
        return ""
    t = prop.get("type")
    if t == "title":
        return "".join([t.get("plain_text", "") for t in prop.get("title", [])])
    elif t == "rich_text":
        return "".join([t.get("plain_text", "") for t in prop.get("rich_text", [])])
    elif t == "multi_select":
        return ", ".join([opt.get("name", "") for opt in prop.get("multi_select", [])])
    elif t == "select":
        select_obj = prop.get("select")
        if select_obj is not None:
            return select_obj.get("name", "")
        return ""
    elif t == "number":
        return str(prop.get("number", ""))
    elif t == "checkbox":
        return str(prop.get("checkbox", ""))
    elif t == "date":
        date_obj = prop.get("date")
        if date_obj is not None:
            return date_obj.get("start", "")
        return ""
    elif t == "people":
        return ", ".join([person.get("name", "") for person in prop.get("people", [])])
    elif t == "relation":
        return ", ".join([rel.get("id", "") for rel in prop.get("relation", [])])
    elif t == "url":
        return prop.get("url", "")
    elif t == "email":
        return prop.get("email", "")
    elif t == "phone_number":
        return prop.get("phone_number", "")
    elif t == "formula":
        formula = prop.get("formula", {})
        if formula.get("type") == "string":
            return formula.get("string", "")
        elif formula.get("type") == "number":
            return str(formula.get("number", ""))
        elif formula.get("type") == "boolean":
            return str(formula.get("boolean", ""))
    elif t == "rollup":
        rollup = prop.get("rollup", {})
        if rollup.get("type") == "array":
            return ", ".join([
                str(item.get("plain_text", ""))
                for item in rollup.get("array", [])
            ])
        elif rollup.get("type") in ["number", "string"]:
            return str(rollup.get(rollup.get("type"), ""))
    return ""

try:
    with open(csv_filename, 'w', newline='', encoding='utf-8') as csvfile:
        header = ["Page_ID", "Qt√©/pers_s", "Ingr√©dient ok", "Type de stock f"]
        csv_writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL, dialect='excel')
        csv_writer.writerow(header)

        while total_extracted < num_rows_to_extract:
            results = notion.databases.query(
                database_id=database_id,
                start_cursor=next_cursor,
                page_size=batch_size,
                timeout=api_timeout_seconds,
                filter={
                    "property": "Type de stock f",
                    "formula": {"string": {"equals": "Autre type"}}
                }
            )
            page_results = results.get("results", [])
            if not page_results:
                print("Aucun r√©sultat trouv√© avec le filtre 'Autre type'")
                break

            for result in page_results:
                if total_extracted >= num_rows_to_extract:
                    break
                properties = result.get("properties", {})

                # R√©cup√©rer l'ID de l'√©l√©ment parent depuis la propri√©t√© "El√©ment parent"
                element_parent_property = properties.get("El√©ment parent", {})
                parent_id = ""

                # V√©rifier le type de la propri√©t√© et extraire l'ID en cons√©quence
                if element_parent_property:
                    if element_parent_property.get("type") == "relation":
                        # Si c'est une relation, prendre le premier ID de la liste
                        relations = element_parent_property.get("relation", [])
                        if relations and len(relations) > 0:
                            parent_id = relations[0].get("id", "")
                    else:
                        # Si ce n'est pas une relation, extraire la valeur comme texte
                        parent_id = extract_property_value(element_parent_property)

                # Si aucun parent_id n'est trouv√©, utiliser l'ID de la page actuelle comme fallback
                if not parent_id:
                    parent_id = result.get("id", "")
                    print(f"Attention: √âl√©ment parent non trouv√© pour {result.get('id')}, utilisation de l'ID de page comme fallback")

                qte_str = extract_property_value(properties.get("Qt√©/pers_s", {}))
                try:
                    qte = float(qte_str.replace(",", "."))
                except (ValueError, AttributeError):
                    qte = 0
                if qte > 0:
                    row_values = [
                        parent_id,  # Utiliser l'ID de l'√©l√©ment parent au lieu de l'ID de la page
                        qte_str,
                        extract_property_value(properties.get("Ingr√©dient ok", {})),
                        extract_property_value(properties.get("Type de stock f", {}))
                    ]
                    csv_writer.writerow(row_values)
                    total_extracted += 1

            next_cursor = results.get("next_cursor")
            if not next_cursor:
                break
            time.sleep(1)
    print(f"Extraction termin√©e. {total_extracted} lignes export√©es dans {csv_filename}.")
except Exception as e:
    print(f"Erreur : {e}")

"""**API Recettes**"""

import csv
import time
import logging
from notion_client import Client
from notion_client.errors import RequestTimeoutError, APIResponseError
import httpx # notion_client peut lever des erreurs httpx

# ========== CONFIGURATION DU LOGGING ==========
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# ========== CONFIGURATION NOTION ==========
NOTION_API_KEY = "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"
DATABASE_ID    = "1d16fa46f8b2805b8377eba7bf668eb5"
SAISON_FILTRE  = "Printemps"

notion = Client(auth=NOTION_API_KEY)
logger.info("Client Notion initialis√©.")
logger.info(f"ID de la base de donn√©es cible : {DATABASE_ID}")
if SAISON_FILTRE:
    logger.info(f"Saison pour le filtre dynamique : {SAISON_FILTRE}")

# ========== PARAM√àTRES D'EXTRACTION ==========
csv_filename         = "Recettes.csv" # Votre nom de fichier original
num_rows_to_extract  = 400
batch_size           = 50
max_retries          = 3
retry_delay_initial  = 5

# ========== D√âFINITION DU FILTRE (Noms v√©rifi√©s par rapport √† votre liste) ==========
filter_conditions = [
    {"property": "El√©ment parent", "relation": {"is_empty": True}},
    {
        "or": [
            {"property": "Saison", "multi_select": {"contains": "Toute l'ann√©e"}},
            *([{"property": "Saison", "multi_select": {"contains": SAISON_FILTRE}}] if SAISON_FILTRE else []),
            {"property": "Saison", "multi_select": {"is_empty": True}}
        ]
    },
    {
        "or": [
            {"property": "Type_plat", "multi_select": {"contains": "Salade"}},
            {"property": "Type_plat", "multi_select": {"contains": "Soupe"}},
            {"property": "Type_plat", "multi_select": {"contains": "Plat"}}
        ]
    }
]
filter_recettes = {"and": filter_conditions}
logger.info(f"Filtre API Notion : {filter_recettes}")


# ========== EN-T√äTE CSV (modifi√©e pour exclure Ingredients_quantite) ==========
header_csv = [
    "Page_ID", "Nom", "ID_Recette", "Saison", # "Ingredients_quantite" supprim√©
    "Calories", "Proteines", "Temps_total", "Aime_pas_princip",
    "Type_plat", "Transportable"
]

# ========== FONCTION D'EXTRACTION DE PROPRI√âT√âS (Identique √† la version pr√©c√©dente) ==========
def get_property_value(prop_data, notion_prop_name_for_log, expected_format_key):
    # ... (la fonction get_property_value reste la m√™me que dans le message pr√©c√©dent)
    if not prop_data: return ""
    prop_type = prop_data.get("type")

    try:
        if expected_format_key == "title":
            return "".join(t.get("text", {}).get("content", "") for t in prop_data.get("title", []))
        # "rollup_text_concat" n'est plus utilis√© car Ingredients_quantite est supprim√©,
        # mais on le garde au cas o√π une autre colonne aurait besoin de ce formatage.
        elif expected_format_key == "rollup_text_concat":
            if prop_type == "rollup":
                arr = prop_data.get("rollup", {}).get("array", [])
                values = []
                for item in arr:
                    if item.get("type") == "rich_text": values.append("".join(t.get("plain_text", "") for t in item.get("rich_text", [])))
                    elif item.get("type") == "title": values.append("".join(t.get("text", {}).get("content", "") for t in item.get("title", [])))
                return ", ".join(filter(None, values))
            return ""
        elif expected_format_key == "unique_id_or_text":
            if prop_type == "unique_id":
                uid = prop_data.get("unique_id", {}); p, n = uid.get("prefix"), uid.get("number")
                return f"{p}-{n}" if p and n is not None else (str(n) if n is not None else "")
            elif prop_type == "title": return get_property_value(prop_data, notion_prop_name_for_log, "title")
            elif prop_type == "rich_text": return get_property_value(prop_data, notion_prop_name_for_log, "rich_text_plain")
            return ""
        elif expected_format_key == "rich_text_plain":
             return "".join(t.get("plain_text", "") for t in prop_data.get("rich_text", []))
        elif expected_format_key == "multi_select_comma_separated":
            if prop_type == "multi_select":
                return ", ".join(filter(None, [o.get("name", "") for o in prop_data.get("multi_select", [])]))
            return ""
        elif expected_format_key == "number_to_string_or_empty":
            if prop_type == "number": num = prop_data.get("number"); return str(num) if num is not None else ""
            return ""
        elif expected_format_key == "formula_number_or_string_or_empty":
            if prop_type == "formula":
                fo = prop_data.get("formula", {}); ft = fo.get("type")
                if ft == "number": num = fo.get("number"); return str(num) if num is not None else ""
                elif ft == "string": return fo.get("string", "")
            return ""
        elif expected_format_key == "rollup_single_number_or_empty":
             if prop_type == "rollup":
                ro = prop_data.get("rollup", {}); rt = ro.get("type")
                if rt == "number": num = ro.get("number"); return str(num) if num is not None else ""
                elif rt == "array":
                    arr = ro.get("array", [])
                    if arr:
                        item = arr[0]; it = item.get("type")
                        if it == "number": num = item.get("number"); return str(num) if num is not None else ""
                        elif it == "formula":
                             fi = item.get("formula", {}); fit = fi.get("type")
                             if fit == "number": num = fi.get("number"); return str(num) if num is not None else ""
             return ""
        elif expected_format_key == "rollup_formula_string_dots_comma_separated":
            if prop_type == "rollup":
                arr = prop_data.get("rollup", {}).get("array", [])
                vals = []
                for item in arr:
                    if item.get("type") == "formula":
                        fo = item.get("formula", {}); ft = fo.get("type")
                        if ft == "string": sv = fo.get("string"); vals.append(sv if sv and sv.strip() else ".")
                        else: vals.append(".")
                    else: vals.append(".")
                return ", ".join(vals)
            return ""
        elif expected_format_key == "select_to_oui_empty":
            if prop_type == "select":
                so = prop_data.get("select"); return "Oui" if so and so.get("name", "").lower() == "oui" else ""
            elif prop_type == "checkbox": return "Oui" if prop_data.get("checkbox", False) else ""
            return ""
    except Exception as e:
        logger.error(f"EXC Formatage: '{notion_prop_name_for_log}' (format: {expected_format_key}): {e}", exc_info=False)
        return "ERREUR_FORMAT"
    return ""

# ========== PROCESSUS D'EXTRACTION ET √âCRITURE CSV ==========
total_extracted_and_written = 0
next_cursor = None
start_time = time.time()

# Noms de propri√©t√©s Notion v√©rifi√©s par rapport √† votre liste du 06/06/2025 09:01
# "Ingredients_quantite" supprim√© du mapping
csv_to_notion_mapping = {
    "Page_ID":              (None, "page_id_special"),
    "Nom":                  ("Nom_plat", "title"),
    "ID_Recette":           ("ID_Recette", "unique_id_or_text"),
    "Saison":               ("Saison", "multi_select_comma_separated"),
    "Calories":             ("Calories Recette", "rollup_single_number_or_empty"),
    "Proteines":            ("Proteines Recette", "rollup_single_number_or_empty"),
    "Temps_total":          ("Temps_total", "formula_number_or_string_or_empty"),
    "Aime_pas_princip":     ("Aime_pas_princip", "rollup_formula_string_dots_comma_separated"),
    "Type_plat":            ("Type_plat", "multi_select_comma_separated"),
    "Transportable":        ("Transportable", "select_to_oui_empty")
}

logger.info(f"Ouverture du fichier '{csv_filename}' pour √©criture.")
with open(csv_filename, "w", newline="", encoding="utf-8") as csvfile:
    writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL)
    writer.writerow(header_csv)

    pages_retrieved_from_api_total = 0

    while total_extracted_and_written < num_rows_to_extract:
        retries = 0
        current_retry_delay = retry_delay_initial

        try:
            query_params = {"database_id": DATABASE_ID, "filter": filter_recettes, "page_size": batch_size}
            if next_cursor: query_params["start_cursor"] = next_cursor

            logger.info(f"Appel API Notion (Curseur: {next_cursor or 'aucun'}).")
            response = notion.databases.query(**query_params)

            pages_batch = response.get("results", [])
            pages_retrieved_from_api_total += len(pages_batch)
            logger.info(f"API a retourn√© {len(pages_batch)} pages pour ce lot. (Total API: {pages_retrieved_from_api_total})")

            next_cursor = response.get("next_cursor")

        except (RequestTimeoutError, httpx.TimeoutException, httpx.ReadTimeout) as e:
            retries += 1; logger.warning(f"Timeout API (tentative {retries}/{max_retries}). Attente {current_retry_delay}s...")
            if retries >= max_retries: logger.error(f"Max timeouts atteints. Abandon."); break
            time.sleep(current_retry_delay); current_retry_delay = min(current_retry_delay*2, 60); continue
        except APIResponseError as e:
            logger.error(f"Erreur API Notion: {e.code} - {e.message}.")
            if e.code in ["validation_error", "invalid_json", "unauthorized", "restricted_resource"]: logger.error("Erreur API non r√©cup√©rable. Abandon."); break
            retries += 1; logger.warning(f"Erreur API (tentative {retries}/{max_retries}). Attente {current_retry_delay}s...")
            if retries >= max_retries: logger.error(f"Max erreurs API atteintes. Abandon."); break
            time.sleep(current_retry_delay); current_retry_delay = min(current_retry_delay*2, 60); continue
        except Exception as e:
            logger.error(f"Erreur inattendue: {e}", exc_info=True); break

        if not pages_batch:
            if pages_retrieved_from_api_total == 0:
                 logger.critical("!!! AUCUNE PAGE RETOURN√âE PAR L'API AVEC LE FILTRE ACTUEL !!!")
                 logger.critical("Cause probable : Noms de propri√©t√©s incorrects dans le filtre OU conditions du filtre trop restrictives OU permissions de l'int√©gration.")
                 logger.critical(f"Filtre utilis√© : {filter_recettes}")
            else:
                 logger.info("Plus de pages √† r√©cup√©rer de l'API.")
            break

        rows_written_this_batch = 0
        for page in pages_batch:
            page_props_raw = page.get("properties", {})
            row_to_write = []
            for csv_col_name in header_csv: # It√®re sur le header_csv qui n'a plus Ingredients_quantite
                notion_prop_name_key, expected_format_key = csv_to_notion_mapping[csv_col_name]
                if csv_col_name == "Page_ID": row_to_write.append(page.get("id", ""))
                else:
                    raw_prop_data = page_props_raw.get(notion_prop_name_key)
                    if raw_prop_data is None and notion_prop_name_key is not None:
                         logger.warning(f"Propri√©t√© Notion '{notion_prop_name_key}' (pour CSV '{csv_col_name}') non trouv√©e dans la page ID {page.get('id')}. Cl√©s dispo: {list(page_props_raw.keys())}")
                    value = get_property_value(raw_prop_data, notion_prop_name_key, expected_format_key)
                    row_to_write.append(value)

            # La condition de saut sur Ingredients_quantite n'est plus n√©cessaire
            writer.writerow(row_to_write)
            rows_written_this_batch +=1
            total_extracted_and_written += 1
            if total_extracted_and_written >= num_rows_to_extract: break

        logger.info(f"{rows_written_this_batch} lignes √©crites au CSV pour ce lot. Total √©crit: {total_extracted_and_written}.")

        if not next_cursor or total_extracted_and_written >= num_rows_to_extract:
            logger.info("Fin (plus de pages ou limite atteinte).")
            break
        time.sleep(0.35)

duration = time.time() - start_time
logger.info(f"Termin√© en {duration:.2f}s. {total_extracted_and_written} recettes √©crites dans '{csv_filename}'.")
if total_extracted_and_written == 0 :
    if pages_retrieved_from_api_total == 0:
        logger.error("R√âSUM√â FINAL : AUCUNE page r√©cup√©r√©e de l'API ET AUCUNE ligne √©crite. Le probl√®me est tr√®s certainement le FILTRE API ou les PERMISSIONS.")
    # Si pages_retrieved_from_api_total > 0 mais total_extracted_and_written == 0,
    # cela indiquerait un probl√®me dans la boucle d'√©criture ou de formatage qui vide toutes les lignes,
    # mais sans le filtre Ingredients_quantite, c'est moins probable.

"""**API Menus**"""

# @title
import csv
from notion_client import Client
from notion_client.errors import RequestTimeoutError # Importer l'erreur sp√©cifique
import time
import httpx # Garder pour le type hint ou si on attrape les deux
import re
import unicodedata
import logging
from datetime import datetime

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- VOS PARAMETRES NOTION ---
notion = Client(auth="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")
database_id = "9025cfa1c18d4501a91dbeb1b10b48bd"  # ID de la base de donn√©es corrig√©
logger.info("Client Notion initialis√©.")
logger.info(f"ID de la base de donn√©es: {database_id}")
# --- FIN PARAMETRES NOTION ---

# Nom du fichier CSV de sortie
csv_filename = "Menus.csv"

# Nombre de lignes VALIDES √† extraire
num_rows_to_extract = 100000

# --- NOMS DES PROPRI√âT√âS NOTION (√Ä MODIFIER ICI SI N√âCESSAIRE) ---
nom_menu_property_name = "Nom Menu"
recette_property_name = "Recette"
date_property_name = "Date"
# --- FIN DES NOMS DE PROPRI√âT√âS NOTION ---

# --- PARAM√àTRES AJUST√âS ---
next_cursor = None
batch_size = 25
max_retries = 7
retry_delay = 10 # Le d√©lai initial
retries = 0
api_timeout_seconds = 180 # Gardons 3 minutes pour l'instant
# --- FIN PARAM√àTRES AJUST√âS ---

total_extracted = 0
start_time_global = time.time()

logger.info(f"D√©but de l'extraction de jusqu'√† {num_rows_to_extract} menus ({nom_menu_property_name}, {recette_property_name}, {date_property_name}) vers '{csv_filename}'...")
logger.info(f"Param√®tres API: batch_size={batch_size}, timeout={api_timeout_seconds}, max_retries={max_retries}")

try:
    # --- TEST DE CONNEXION INITIALE √Ä LA BASE DE DONN√âES ---
    try:
        database_info = notion.databases.retrieve(database_id)
        logger.info(f"Informations de la base de donn√©es r√©cup√©r√©es avec succ√®s: {database_info.get('title')}")
    except Exception as e:
        logger.error(f"Erreur lors de la r√©cup√©ration des informations de la base de donn√©es initiale. V√©rifiez votre jeton et l'ID de la base de donn√©es : {e}")
        exit()
    # --- FIN TEST DE CONNEXION INITIALE ---

    with open(csv_filename, 'w', newline='', encoding='utf-8') as csvfile:
        csv_writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL, dialect='excel')
        header = [nom_menu_property_name, recette_property_name, date_property_name]  # Utilisation des variables pour l'en-t√™te
        csv_writer.writerow(header)

        while total_extracted < num_rows_to_extract:
            page_start_time = time.time()
            try:
                request_batch_size = batch_size
                logger.debug(f"Demande √† Notion: start_cursor={next_cursor}, page_size={request_batch_size}")

                results = notion.databases.query(
                    database_id=database_id,
                    start_cursor=next_cursor,
                    page_size=request_batch_size,
                    filter={
                        "and": [
                            # --- AJOUT DU FILTRE SUR RECETTE NON VIDE ---
                            {"property": recette_property_name, "relation": {"is_not_empty": True}}, # Utilisation de la variable
                        ]
                    },
                    timeout=api_timeout_seconds
                )

                # Si la requ√™te r√©ussit, r√©initialiser les compteurs de tentative
                retries = 0
                retry_delay = 10 # R√©initialiser le d√©lai de base

                page_results = results.get("results", [])
                if not page_results:
                    logger.info("Aucun r√©sultat retourn√© par l'API ou fin de la base de donn√©es atteinte.")
                    break

                logger.info(f"Re√ßu {len(page_results)} menus de Notion. Traitement ({nom_menu_property_name}, {recette_property_name}, {date_property_name})...")
                page_valid_count = 0

                for result in page_results:
                    if total_extracted >= num_rows_to_extract:
                        break # Sortir si limite atteinte

                    row_values = []
                    properties = result.get("properties", {})

                    # 1. Nom Menu
                    nom_menu_value = ""
                    if nom_menu_property_name in properties: # Utilisation de la variable
                        name_property = properties[nom_menu_property_name] # Utilisation de la variable
                        nom_menu_value = "".join([text.get("plain_text", "") for text in name_property.get("title", []) or name_property.get("rich_text", [])])
                    row_values.append(nom_menu_value.strip())

                    # 2. Recette (Gestion de la relation - Extraction des IDs)
                    recette_value = ""
                    if recette_property_name in properties: # Utilisation de la variable
                        prop = properties[recette_property_name] # Utilisation de la variable
                        # Si c'est une relation directe
                        if prop["type"] == "relation" and prop["relation"]:
                            recette_value = ", ".join([relation["id"] for relation in prop["relation"]])
                        # Si c'est un rollup de type array (agr√©gation de relations)
                        elif prop["type"] == "rollup" and prop["rollup"]:
                            rollup_data = prop["rollup"]
                            if rollup_data.get("type") == "array" and rollup_data.get("array"):
                                recette_ids = []
                                for item in rollup_data["array"]:
                                    # Les items de rollup de relation sont eux-m√™mes des objets relation
                                    if item.get("id"):
                                        recette_ids.append(item["id"])
                                    elif item.get("relation"):
                                        recette_ids.extend([rel.get("id") for rel in item["relation"] if rel.get("id")])
                                recette_value = ", ".join(recette_ids)
                    row_values.append(recette_value)

                    # 3. Date (Formatage de la date)
                    date_value = ""
                    if date_property_name in properties: # Utilisation de la variable
                        date_property = properties[date_property_name] # Utilisation de la variable
                        if date_property["type"] == "date" and date_property.get("date") and date_property["date"].get("start"):
                            date_str = date_property["date"]["start"]
                            # Convertir la cha√Æne de date ISO 8601 en format de base (YYYY-MM-DD)
                            date_object = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                            date_value = date_object.strftime('%Y-%m-%d')
                    row_values.append(date_value)

                    csv_writer.writerow(row_values)
                    total_extracted += 1
                    page_valid_count += 1

                page_end_time = time.time()
                logger.info(f"Page trait√©e en {page_end_time - page_start_time:.2f} sec. {page_valid_count} menus ajout√©s (Total: {total_extracted}/{num_rows_to_extract}).")

                if total_extracted >= num_rows_to_extract:
                    logger.info(f"Limite de {num_rows_to_extract} menus atteinte.")
                    break
                next_cursor = results.get("next_cursor")
                if not next_cursor:
                    logger.info("Fin des pages retourn√©es par l'API (next_cursor est None).")
                    break

                logger.info(f"Passage √† la page suivante (next_cursor: {str(next_cursor)[:10]}...).")
                time.sleep(1) # Pause entre les pages

            except (httpx.TimeoutException, RequestTimeoutError) as e: # Attrape les deux types de timeout
                retries += 1
                logger.warning(f"Timeout d√©tect√© ({type(e).__name__}). Tentative {retries}/{max_retries}...")
                if retries >= max_retries:
                    logger.error(f"Nombre maximum de tentatives atteint ({max_retries}) apr√®s Timeout. Abandon.")
                    break # Arr√™ter la boucle while si max_retries atteint

                logger.warning(f"Attente de {retry_delay} secondes avant la nouvelle tentative...")
                time.sleep(retry_delay)
                retry_delay *= 2 # Augmenter le d√©lai pour la prochaine fois (backoff exponentiel)
                continue # Recommencer la tentative pour cette page (le d√©but du bloc try)

            except Exception as e:
                logger.exception(f"Une erreur inattendue et non li√©e au timeout est survenue pendant la boucle : {e}")
                break # Arr√™ter en cas d'erreur grave impr√©vue

except IOError as e:
    logger.error(f"Erreur: Impossible d'√©crire dans le fichier '{csv_filename}'. {e}")
except Exception as e:
    logger.exception(f"Erreur g√©n√©rale avant la boucle principale : {e}")

# --- Message final ---
end_time_global = time.time()
total_duration = end_time_global - start_time_global
final_message = f"Extraction termin√©e en {total_duration:.2f} secondes. {total_extracted} menus ({nom_menu_property_name}, {recette_property_name}, {date_property_name}) "
if total_extracted < num_rows_to_extract and next_cursor is None:
    final_message += f"trouv√©s (toute la base de donn√©es a √©t√© parcourue) et sauvegard√©s dans '{csv_filename}'"
elif total_extracted < num_rows_to_extract:
    final_message += f"trouv√©s (moins que les {num_rows_to_extract} demand√©es, possible arr√™t pr√©matur√© ou erreur) et sauvegard√©s dans '{csv_filename}'"
else:
    final_message += f"sauvegard√©s dans '{csv_filename}'"
print(final_message)
logger.info(final_message)

"""**G√©n√©rateur de Menus**"""

# @title
import pandas as pd
import random
import logging
from datetime import datetime, timedelta # Assurez-vous que timedelta est import√©

# Constantes globales
NB_JOURS_ANTI_REPETITION = 42
FICHIER_RECETTES = "Recettes.csv"
FICHIER_PLANNING = "Planning.csv"
FICHIER_MENUS = "Menus.csv" # Pour l'historique
FICHIER_INGREDIENTS = "Ingredients.csv" # Assurez-vous que ce nom est correct
FICHIER_INGREDIENTS_RECETTES = "Ingredients_recettes.csv" # Assurez-vous que ce nom est correct
FICHIER_SORTIE_MENU_CSV = "Menu_genere.csv"
FICHIER_SORTIE_LISTES_TXT = "recapitulatif_ingredients.txt" # Pour toutes les listes

COLONNE_NOM = "Nom"
COLONNE_TEMPS_TOTAL = "Temps_total"
COLONNE_ID_RECETTE = "Page_ID" # Utilis√© comme ID pour Recettes et Ingredients_recettes
COLONNE_ID_INGREDIENT = "Page_ID" # Utilis√© comme ID pour Ingredients
COLONNE_AIME_PAS_PRINCIP = "Aime_pas_princip"

VALEUR_DEFAUT_TEMPS_PREPARATION = 10
TEMPS_MAX_EXPRESS = 20
TEMPS_MAX_RAPIDE = 30
REPAS_EQUILIBRE = 700

logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(filename)s:%(lineno)d - %(message)s')
logger = logging.getLogger(__name__)

def verifier_colonnes(df, colonnes_attendues, nom_fichier=""):
    colonnes_manquantes = [col for col in colonnes_attendues if col not in df.columns]
    if colonnes_manquantes:
        raise ValueError(f"Colonnes manquantes dans {nom_fichier}: {colonnes_manquantes}")

class RecetteManager:
    def __init__(self, df_recettes, df_ingredients, df_ingredients_recettes):
        self.df_recettes = df_recettes.copy()
        # S'assurer que Page_ID est l'index si la colonne existe
        if COLONNE_ID_RECETTE in self.df_recettes.columns and not self.df_recettes.index.name == COLONNE_ID_RECETTE:
            self.df_recettes = self.df_recettes.set_index(COLONNE_ID_RECETTE, drop=False)

        self.df_ingredients_initial = df_ingredients.copy() # Stock initial avec noms, etc. Ne sera pas modifi√©.
        self.df_ingredients_recettes = df_ingredients_recettes.copy()

        self.stock_simule = self.df_ingredients_initial.copy() # Copie pour la simulation
        if "Qte reste" in self.stock_simule.columns:
            self.stock_simule["Qte reste"] = pd.to_numeric(self.stock_simule["Qte reste"], errors='coerce').fillna(0).astype(float)
        else:
            logger.error("'Qte reste' manquante dans df_ingredients pour stock_simule.")
            self.stock_simule["Qte reste"] = 0.0
        self.anti_gaspi_ingredients = self._trouver_ingredients_stock_eleve()

    def get_ingredients_for_recipe(self, recette_id_str):
        try:
            recette_id_str = str(recette_id_str)
            ingredients = self.df_ingredients_recettes[
                self.df_ingredients_recettes[COLONNE_ID_RECETTE].astype(str) == recette_id_str
            ][["Ingr√©dient ok", "Qt√©/pers_s"]].to_dict('records')
            if not ingredients:
                logger.debug(f"Aucun ingr√©dient trouv√© pour recette {recette_id_str} dans df_ingredients_recettes")
            return ingredients
        except Exception as e:
            logger.error(f"Erreur r√©cup√©ration ingr√©dients pour {recette_id_str} : {e}")
            return []

    def _trouver_ingredients_stock_eleve(self):
        seuil_gr = 100
        seuil_pc = 1
        ingredients_stock = {}
        if not all(col in self.stock_simule.columns for col in ["Qte reste", "unit√©", COLONNE_ID_INGREDIENT, "Nom"]):
            logger.warning("Colonnes manquantes dans stock_simule pour _trouver_ingredients_stock_eleve.")
            return {}

        for _, row in self.stock_simule.iterrows():
            try:
                qte = float(str(row["Qte reste"]).replace(",", "."))
                unite = str(row["unit√©"]).lower()
                page_id = str(row[COLONNE_ID_INGREDIENT])

                if (unite in ["gr", "g", "ml", "cl"] and qte >= seuil_gr) or \
                   (unite in ["pc", "tranches"] and qte >= seuil_pc):
                    ingredients_stock[page_id] = row["Nom"]
            except (ValueError, KeyError) as e:
                logger.debug(f"Erreur dans _trouver_ingredients_stock_eleve pour ligne {row.get('Nom', 'ID inconnu')}: {e}")
                continue
        return ingredients_stock

    def recette_utilise_ingredient_anti_gaspi(self, recette_id_str):
        try:
            ingredients = self.get_ingredients_for_recipe(recette_id_str)
            return any(str(ing.get("Ingr√©dient ok")) in self.anti_gaspi_ingredients for ing in ingredients if ing.get("Ingr√©dient ok"))
        except Exception as e:
            logger.error(f"Erreur dans recette_utilise_ingredient_anti_gaspi pour {recette_id_str}: {e}")
            return False

    def calculer_quantite_necessaire(self, recette_id_str, nb_personnes):
        ingredients_necessaires = {}
        try:
            ingredients_recette = self.get_ingredients_for_recipe(recette_id_str)
            if not ingredients_recette:
                return {}

            for ing in ingredients_recette:
                try:
                    ing_id = str(ing.get("Ingr√©dient ok"))
                    if not ing_id or ing_id.lower() in ['nan', 'none', '']:
                        continue
                    qte_str = str(ing.get("Qt√©/pers_s", "0")).replace(',', '.')
                    qte_par_personne = float(qte_str)
                    ingredients_necessaires[ing_id] = qte_par_personne * nb_personnes
                except (ValueError, TypeError, KeyError) as e:
                    logger.debug(f"Erreur calcul quantit√© ingr√©dient {ing.get('Ingr√©dient ok')} pour recette {recette_id_str}: {e}. Qt√© str: '{ing.get('Qt√©/pers_s')}'")
                    continue
            return ingredients_necessaires
        except Exception as e:
            logger.error(f"Erreur globale calcul_quantite_necessaire pour {recette_id_str}: {e}")
            return {}

    def evaluer_disponibilite_et_manquants(self, recette_id_str, nb_personnes):
        """
        √âvalue la disponibilit√© et identifie les quantit√©s manquantes pour une recette.
        Retourne: score_moyen_dispo, pourcentage_dispo, dict_ingredients_manquants {ing_id: qte_manquante}
        """
        ingredients_necessaires = self.calculer_quantite_necessaire(recette_id_str, nb_personnes)
        if not ingredients_necessaires:
            return 0, 0, {}

        total_ingredients_definis = len(ingredients_necessaires)
        ingredients_disponibles_compteur = 0
        score_total_dispo = 0
        ingredients_manquants = {} # NOUVEAU

        for ing_id, qte_necessaire in ingredients_necessaires.items():
            ing_id_str = str(ing_id)
            ing_stock_df = self.stock_simule[self.stock_simule[COLONNE_ID_INGREDIENT].astype(str) == ing_id_str]
            qte_en_stock = 0.0
            if not ing_stock_df.empty:
                try:
                    qte_en_stock = float(ing_stock_df["Qte reste"].iloc[0])
                except (ValueError, IndexError, KeyError) as e:
                    logger.error(f"Erreur lecture stock pour {ing_id_str} rec {recette_id_str}: {e}")
            else:
                logger.debug(f"Ingr√©dient {ing_id_str} (recette {recette_id_str}) non trouv√© dans stock_simule.")

            ratio_dispo = 0.0
            if qte_necessaire > 0:
                ratio_dispo = min(1.0, qte_en_stock / qte_necessaire)

            score_total_dispo += ratio_dispo
            if ratio_dispo >= 1.0:
                ingredients_disponibles_compteur += 1
            else:
                qte_manquante = max(0, qte_necessaire - qte_en_stock)
                ingredients_manquants[ing_id_str] = qte_manquante # Enregistrer les manquants

        score_moyen_dispo = score_total_dispo / total_ingredients_definis if total_ingredients_definis > 0 else 0
        pourcentage_dispo = (ingredients_disponibles_compteur / total_ingredients_definis) * 100 if total_ingredients_definis > 0 else 0

        return score_moyen_dispo, pourcentage_dispo, ingredients_manquants # Retourner les manquants

    def ajuster_stock_simule(self, recette_id_str, nb_personnes):
        ingredients_necessaires = self.calculer_quantite_necessaire(recette_id_str, nb_personnes)
        for ing_id, qte_necessaire in ingredients_necessaires.items():
            ing_id_str = str(ing_id)
            idx = self.stock_simule[self.stock_simule[COLONNE_ID_INGREDIENT].astype(str) == ing_id_str].index
            if not idx.empty:
                self.stock_simule.loc[idx, "Qte reste"] -= qte_necessaire
                # S'assurer que le stock ne devient pas n√©gatif
                self.stock_simule.loc[idx, "Qte reste"] = self.stock_simule.loc[idx, "Qte reste"].apply(lambda x: max(0, x))
            else:
                logger.warning(f"Ingr√©dient {ing_id_str} de la recette {recette_id_str} non trouv√© dans le stock simule pour ajustement.")

    def _recuperer_nom_ingredient(self, ingredient_id):
        # Assurez-vous que COLONNE_ID_INGREDIENT est un Page_ID ou un ID unique
        # et que "Nom" est le nom de la colonne des noms dans df_ingredients_initial
        if not (COLONNE_ID_INGREDIENT in self.df_ingredients_initial.columns and "Nom" in self.df_ingredients_initial.columns):
            logger.error(f"Colonnes essentielles manquantes dans df_ingredients_initial: '{COLONNE_ID_INGREDIENT}' ou 'Nom'.")
            return f"Nom inconnu ({ingredient_id})"

        try:
            # Conversion en str pour la comparaison pour √©viter les probl√®mes de type
            ingredient_info = self.df_ingredients_initial[
                self.df_ingredients_initial[COLONNE_ID_INGREDIENT].astype(str) == str(ingredient_id)
            ]
            if not ingredient_info.empty:
                return ingredient_info["Nom"].iloc[0]
        except Exception as e:
            logger.error(f"Erreur lors de la r√©cup√©ration du nom pour l'ingr√©dient ID {ingredient_id}: {e}")
        return f"Nom inconnu ({ingredient_id})"

    def generer_liste_courses(self, menu_genere_df, planning_df):
        logger.info("D√©but de la g√©n√©ration de la liste de courses.")
        liste_courses = {}
        ingredients_par_repas = {} # Pour le r√©capitulatif d√©taill√©

        # Renommer 'ID_Recette' en 'Recette ID' pour unifier avec les IDs de Menus
        df_recettes_temp = self.df_recettes.rename(columns={"ID_Recette": "Recette ID"})

        # Joindre le menu g√©n√©r√© avec les recettes pour obtenir les IDs de recettes
        menu_avec_ids = pd.merge(
            menu_genere_df,
            df_recettes_temp[[COLONNE_NOM, "Recette ID"]].drop_duplicates(subset=[COLONNE_NOM]),
            on=COLONNE_NOM,
            how='left'
        )

        # Ajouter la colonne Participants du planning au menu g√©n√©r√©
        menu_avec_ids = pd.merge(
            menu_avec_ids,
            planning_df[['Date', 'Participant(s)']],
            on='Date',
            how='left'
        )
        menu_avec_ids['Participant(s)'] = pd.to_numeric(menu_avec_ids['Participant(s)'], errors='coerce').fillna(0).astype(int)

        # Assurez-vous que la colonne 'Recette ID' est pr√©sente et non vide
        if 'Recette ID' not in menu_avec_ids.columns or menu_avec_ids['Recette ID'].isnull().all():
            logger.error("La colonne 'Recette ID' est manquante ou vide apr√®s jointure. V√©rifiez le nom de colonne et les donn√©es de Recettes.csv.")
            return {}, {} # Retourne des dictionnaires vides si erreur critique

        for index, row in menu_avec_ids.iterrows():
            recette_id = str(row["Recette ID"])
            nb_personnes = row["Participant(s)"]
            date_repas = row["Date"]
            nom_repas = row[COLONNE_NOM]

            logger.debug(f"Traitement du repas '{nom_repas}' du {date_repas} pour {nb_personnes} personnes.")

            ingredients_necessaires = self.calculer_quantite_necessaire(recette_id, nb_personnes)
            if not ingredients_necessaires:
                logger.warning(f"Aucun ingr√©dient n√©cessaire trouv√© pour la recette '{nom_repas}' (ID: {recette_id}).")
                continue

            for ing_id, qte_necessaire in ingredients_necessaires.items():
                nom_ingredient = self._recuperer_nom_ingredient(ing_id)
                ing_info_df = self.df_ingredients_initial[self.df_ingredients_initial[COLONNE_ID_INGREDIENT].astype(str) == str(ing_id)]

                if not ing_info_df.empty:
                    unite = ing_info_df["unit√©"].iloc[0]
                    type_stock = ing_info_df["Type de stock"].iloc[0]
                    qte_en_stock = float(ing_info_df["Qte reste"].iloc[0])

                    qte_achetee = 0.0
                    if qte_necessaire > qte_en_stock:
                        qte_achetee = qte_necessaire - qte_en_stock
                        logger.debug(f"Besoin d'acheter {qte_achetee:.2f} {unite} de {nom_ingredient} (stock: {qte_en_stock}, n√©cessaire: {qte_necessaire}).")

                    if qte_achetee > 0:
                        if nom_ingredient not in liste_courses:
                            liste_courses[nom_ingredient] = {"quantite": 0.0, "unite": unite, "type_stock": type_stock}
                        liste_courses[nom_ingredient]["quantite"] += qte_achetee
                else:
                    logger.warning(f"Ingr√©dient {nom_ingredient} (ID: {ing_id}) non trouv√© dans la base des ingr√©dients initiaux. Ajout direct √† la liste de courses.")
                    if nom_ingredient not in liste_courses:
                        liste_courses[nom_ingredient] = {"quantite": 0.0, "unite": "unit√©", "type_stock": "Inconnu"} # Unit√©s par d√©faut
                    liste_courses[nom_ingredient]["quantite"] += qte_necessaire

                # Pour le r√©capitulatif d√©taill√© par repas
                if date_repas not in ingredients_par_repas:
                    ingredients_par_repas[date_repas] = {}
                if nom_repas not in ingredients_par_repas[date_repas]:
                    ingredients_par_repas[date_repas][nom_repas] = []
                ingredients_par_repas[date_repas][nom_repas].append({
                    "nom": nom_ingredient,
                    "qte_necessaire": qte_necessaire,
                    "unite": unite if 'unite' in locals() else "unit√©",
                    "qte_en_stock": qte_en_stock if 'qte_en_stock' in locals() else 0,
                    "qte_achetee": qte_achetee if 'qte_achetee' in locals() else 0
                })

        logger.info("G√©n√©ration de la liste de courses termin√©e.")
        return liste_courses, ingredients_par_repas

class MenuGenerator:
    def __init__(self, df_planning, df_recettes, df_menus_historique, recette_manager):
        self.df_planning = df_planning.copy()
        self.df_recettes = df_recettes.copy()
        self.df_menus_historique = df_menus_historique.copy()
        self.recette_manager = recette_manager # Utilisation de la classe RecetteManager

        # Nettoyage et conversion des colonnes cl√©s
        self._preparer_donnees()

    def _preparer_donnees(self):
        # Planning
        self.df_planning['Date'] = pd.to_datetime(self.df_planning['Date'], format='%d/%m/%Y', errors='coerce')
        self.df_planning = self.df_planning.dropna(subset=['Date'])
        self.df_planning['Participant(s)'] = pd.to_numeric(self.df_planning['Participant(s)'], errors='coerce').fillna(1).astype(int)

        # Recettes: Assurez-vous que les colonnes existent avant d'essayer d'y acc√©der
        colonnes_recettes_req = [COLONNE_NOM, COLONNE_TEMPS_TOTAL, COLONNE_ID_RECETTE, "Calories", "Proteines", "Type_plat", COLONNE_AIME_PAS_PRINCIP]
        verifier_colonnes(self.df_recettes, colonnes_recettes_req, FICHIER_RECETTES)

        self.df_recettes = self.df_recettes.copy() # √âviter SettingWithCopyWarning
        self.df_recettes[COLONNE_TEMPS_TOTAL] = pd.to_numeric(self.df_recettes[COLONNE_TEMPS_TOTAL], errors='coerce').fillna(VALEUR_DEFAUT_TEMPS_PREPARATION)
        # Convertir les colonnes ID_Recette en string
        self.df_recettes[COLONNE_ID_RECETTE] = self.df_recettes[COLONNE_ID_RECETTE].astype(str)
        self.df_recettes['Calories'] = pd.to_numeric(self.df_recettes['Calories'], errors='coerce').fillna(0)
        self.df_recettes['Proteines'] = pd.to_numeric(self.df_recettes['Proteines'], errors='coerce').fillna(0)

        # Menus Historique
        if not self.df_menus_historique.empty:
            colonnes_menus_hist_req = ["Date", COLONNE_NOM]
            verifier_colonnes(self.df_menus_historique, colonnes_menus_hist_req, FICHIER_MENUS)
            self.df_menus_historique['Date'] = pd.to_datetime(self.df_menus_historique['Date'], errors='coerce')
            self.df_menus_historique = self.df_menus_historique.dropna(subset=['Date'])
            self.df_menus_historique[COLONNE_NOM] = self.df_menus_historique[COLONNE_NOM].astype(str)
        else:
            logger.info("Historique des menus vide ou non disponible.")

    def _filtrer_recettes_recemment_mangees(self, recettes_potentielles, date_repas_actuelle):
        if self.df_menus_historique.empty:
            return recettes_potentielles

        date_limite = date_repas_actuelle - timedelta(days=NB_JOURS_ANTI_REPETITION)
        recettes_recentes = self.df_menus_historique[
            self.df_menus_historique['Date'] > date_limite
        ][COLONNE_NOM].unique()

        # Filtrer en utilisant la colonne COLONNE_NOM (Nom du plat)
        recettes_filtrees = recettes_potentielles[
            ~recettes_potentielles[COLONNE_NOM].isin(recettes_recentes)
        ].copy() # Utiliser .copy() pour √©viter SettingWithCopyWarning
        return recettes_filtrees

    def _filtrer_recettes_preference(self, recettes, preferences_a_exclure):
        if not preferences_a_exclure:
            return recettes

        # Assurez-vous que la colonne existe
        if COLONNE_AIME_PAS_PRINCIP not in recettes.columns:
            logger.warning(f"La colonne '{COLONNE_AIME_PAS_PRINCIP}' est manquante dans les recettes. Le filtre de pr√©f√©rence ne sera pas appliqu√©.")
            return recettes

        # Convertir les pr√©f√©rences en une liste de cha√Ænes √† rechercher
        preferences_set = set(p.strip().lower() for p in preferences_a_exclure if p and p.strip())
        if not preferences_set:
            return recettes

        # Filtrer les recettes qui contiennent l'une des pr√©f√©rences √† exclure
        # Convertir les valeurs de la colonne en minuscules pour la comparaison
        # G√©rer les NaN en les convertissant en cha√Ænes vides
        recettes_filtrees = recettes[
            ~recettes[COLONNE_AIME_PAS_PRINCIP].astype(str).str.lower().apply(
                lambda x: any(pref in x for pref in preferences_set)
            )
        ].copy()
        return recettes_filtrees

    def _filtrer_recettes_par_type(self, recettes, type_repas):
        type_plat_map = {
            "D√©jeuner": ["Salade", "Soupe", "Plat"],
            "D√Æner": ["Salade", "Soupe", "Plat"]
        }
        types_autorises = type_plat_map.get(type_repas)
        if not types_autorises:
            logger.warning(f"Type de repas '{type_repas}' non reconnu pour le filtrage par type de plat.")
            return recettes.copy() # Retourne une copie si aucun filtre n'est appliqu√©

        # Assurez-vous que la colonne 'Type_plat' est du bon type et existe
        if 'Type_plat' not in recettes.columns:
            logger.warning("La colonne 'Type_plat' est manquante dans les recettes. Le filtre par type de plat ne sera pas appliqu√©.")
            return recettes.copy()

        # Filtrer les recettes dont le 'Type_plat' contient au moins un des types autoris√©s
        # Convertir la colonne en cha√Æne et g√©rer les NaN
        recettes_filtrees = recettes[
            recettes['Type_plat'].astype(str).apply(
                lambda x: any(tp in x for tp in types_autorises)
            )
        ].copy()
        return recettes_filtrees

    def _evaluer_recettes(self, recettes_candidates, nb_personnes, preferences_a_exclure=[]):
        evaluations = []
        for index, recette in recettes_candidates.iterrows():
            recette_id = str(recette[COLONNE_ID_RECETTE])
            nom_recette = recette[COLONNE_NOM]
            temps_total = recette[COLONNE_TEMPS_TOTAL]
            calories = recette['Calories']
            proteines = recette['Proteines']
            # Convertir Aime_pas_princip en liste de cha√Ænes minuscules
            aime_pas = [s.strip().lower() for s in str(recette[COLONNE_AIME_PAS_PRINCIP]).split(',') if s.strip()]

            score_dispo, pourcentage_dispo, ingredients_manquants = self.recette_manager.evaluer_disponibilite_et_manquants(recette_id, nb_personnes)

            # --- Calcul du score de pr√©f√©rence ---
            score_preference = 1.0
            for pref in preferences_a_exclure:
                if pref.lower() in aime_pas:
                    score_preference = 0.0 # P√©nalit√© maximale si contient une pr√©f√©rence √† exclure
                    break

            # --- Calcul du score de temps ---
            score_temps = 1.0
            if temps_total > TEMPS_MAX_RAPIDE:
                score_temps = 0.5 # P√©nalit√© pour les recettes trop longues
            elif temps_total > TEMPS_MAX_EXPRESS:
                score_temps = 0.8 # P√©nalit√© mod√©r√©e

            # --- Calcul du score nutritionnel ---
            score_nutri = 1.0
            # Exemple: bonus si les calories sont proches d'un id√©al, ou si prot√©ines sont √©lev√©es
            if REPAS_EQUILIBRE > 0:
                deviation_calories = abs(calories - REPAS_EQUILIBRE) / REPAS_EQUILIBRE
                score_nutri *= (1 - min(deviation_calories, 0.5)) # Max 50% de p√©nalit√©

            # Pond√©ration des scores (ajustez ces poids selon l'importance)
            poids_dispo = 0.4
            poids_preference = 0.2
            poids_temps = 0.2
            poids_nutri = 0.2

            # Score final agr√©g√©
            score_final = (score_dispo * poids_dispo +
                           score_preference * poids_preference +
                           score_temps * poids_temps +
                           score_nutri * poids_nutri)

            evaluations.append({
                'recette': recette,
                'score_final': score_final,
                'score_dispo': score_dispo,
                'pourcentage_dispo': pourcentage_dispo,
                'ingredients_manquants': ingredients_manquants,
                'score_preference': score_preference,
                'score_temps': score_temps,
                'score_nutri': score_nutri
            })
        return evaluations

    def generer_menu(self, preferences_a_exclure=[]):
        menu_genere = []
        df_planning_sort = self.df_planning.sort_values(by='Date').copy()

        for index, jour in df_planning_sort.iterrows():
            date_repas_actuelle = jour['Date']
            nb_personnes = jour['Participant(s)']
            type_repas = jour['Type de repas'] # "D√©jeuner" ou "D√Æner"

            logger.info(f"G√©n√©ration du menu pour le {date_repas_actuelle.strftime('%d/%m/%Y')} - {type_repas} ({nb_personnes} pers.)")

            recettes_candidates = self.df_recettes.copy() # Partir de toutes les recettes

            # 1. Filtrer les recettes r√©cemment mang√©es
            recettes_candidates = self._filtrer_recettes_recemment_mangees(recettes_candidates, date_repas_actuelle)
            if recettes_candidates.empty:
                logger.warning(f"Aucune recette disponible apr√®s le filtre anti-r√©p√©tition pour {date_repas_actuelle}.")
                continue

            # 2. Filtrer par type de plat (D√©jeuner/D√Æner)
            recettes_candidates = self._filtrer_recettes_par_type(recettes_candidates, type_repas)
            if recettes_candidates.empty:
                logger.warning(f"Aucune recette disponible apr√®s le filtre par type de plat pour {date_repas_actuelle} ({type_repas}).")
                continue

            # 3. √âvaluer les recettes candidates restantes
            evaluations = self._evaluer_recettes(recettes_candidates, nb_personnes, preferences_a_exclure)
            if not evaluations:
                logger.warning(f"Aucune recette n'a pu √™tre √©valu√©e pour {date_repas_actuelle}.")
                continue

            # Trier les recettes par score final (descendant)
            evaluations_triees = sorted(evaluations, key=lambda x: x['score_final'], reverse=True)

            recette_choisie = None
            for eval_recette in evaluations_triees:
                recette = eval_recette['recette']
                score_final = eval_recette['score_final']
                score_dispo = eval_recette['score_dispo']
                pourcentage_dispo = eval_recette['pourcentage_dispo']
                ingredients_manquants = eval_recette['ingredients_manquants']

                logger.info(f"  Recette candidate: {recette[COLONNE_NOM]} (Score: {score_final:.2f}, Dispo: {pourcentage_dispo:.1f}%)")

                # Crit√®re de s√©lection : score de disponibilit√© doit √™tre > 0 (au moins 1 ingr√©dient dispo)
                # et le score final doit √™tre suffisamment bon (ex: > 0.5)
                if score_dispo > 0 and score_final > 0.4: # Ajustez ce seuil si n√©cessaire
                    recette_choisie = recette
                    # Ajuster le stock simul√© avec la recette choisie
                    self.recette_manager.ajuster_stock_simule(str(recette_choisie[COLONNE_ID_RECETTE]), nb_personnes)
                    logger.info(f"‚úÖ Recette s√©lectionn√©e : {recette_choisie[COLONNE_NOM]} (Score final: {score_final:.2f})")
                    break
                else:
                    logger.debug(f"  Recette {recette[COLONNE_NOM]} rejet√©e (Dispo: {pourcentage_dispo:.1f}%, Score: {score_final:.2f}).")


            if recette_choisie is None:
                logger.warning(f"Impossible de trouver une recette adapt√©e pour {date_repas_actuelle.strftime('%d/%m/%Y')} - {type_repas}. Ajout d'un repas 'Plat √† d√©finir'.")
                menu_genere.append({
                    'Date': date_repas_actuelle.strftime('%d/%m/%Y'),
                    'Jour': date_repas_actuelle.strftime('%A'),
                    'Type de repas': type_repas,
                    'Participant(s)': nb_personnes,
                    'Nom': 'Plat √† d√©finir',
                    'ID_Recette': 'N/A',
                    'Temps_total': 0,
                    'Calories': 0,
                    'Proteines': 0,
                    'Aime_pas_princip': '',
                    'Transportable': ''
                })
            else:
                menu_genere.append({
                    'Date': date_repas_actuelle.strftime('%d/%m/%Y'),
                    'Jour': date_repas_actuelle.strftime('%A'),
                    'Type de repas': type_repas,
                    'Participant(s)': nb_personnes,
                    'Nom': recette_choisie[COLONNE_NOM],
                    'ID_Recette': recette_choisie[COLONNE_ID_RECETTE],
                    'Temps_total': recette_choisie[COLONNE_TEMPS_TOTAL],
                    'Calories': recette_choisie['Calories'],
                    'Proteines': recette_choisie['Proteines'],
                    'Aime_pas_princip': recette_choisie[COLONNE_AIME_PAS_PRINCIP],
                    'Transportable': recette_choisie['Transportable']
                })
        return pd.DataFrame(menu_genere)

# --- Ex√©cution principale ---
if __name__ == "__main__":
    logger.info("D√©marrage du script de g√©n√©ration de menus.")

    # Chargement des donn√©es (simulons les chargements ici)
    try:
        # Assurez-vous que df_planning est d√©j√† charg√© depuis le bloc initial
        # df_planning = pd.read_csv(FICHIER_PLANNING, sep=None, engine='python') # Cette ligne est d√©j√† g√©r√©e en d√©but de script
        df_recettes = pd.read_csv(FICHIER_RECETTES, encoding='utf-8')
        df_menus = pd.read_csv(FICHIER_MENUS, encoding='utf-8')
        df_ingredients = pd.read_csv(FICHIER_INGREDIENTS, encoding='utf-8')
        df_ingredients_recettes = pd.read_csv(FICHIER_INGREDIENTS_RECETTES, encoding='utf-8')

        logger.info(f"Fichiers charg√©s : {FICHIER_PLANNING}, {FICHIER_RECETTES}, {FICHIER_MENUS}, {FICHIER_INGREDIENTS}, {FICHIER_INGREDIENTS_RECETTES}")
        logger.info(f"Planning head:\n{df_planning.head()}")
        logger.info(f"Recettes head:\n{df_recettes.head()}")
        logger.info(f"Menus historique head:\n{df_menus.head()}")
        logger.info(f"Ingr√©dients head:\n{df_ingredients.head()}")
        logger.info(f"Ingr√©dients recettes head:\n{df_ingredients_recettes.head()}")

    except FileNotFoundError as e:
        logger.critical(f"Erreur: Fichier de donn√©es manquant : {e}. Assurez-vous que tous les CSV sont pr√©sents.")
        exit() # Arr√™te l'ex√©cution si un fichier manque
    except pd.errors.EmptyDataError as e:
        logger.critical(f"Erreur: Le fichier est vide : {e}. Veuillez v√©rifier son contenu.")
        exit()
    except Exception as e:
        logger.critical(f"Erreur lors du chargement des fichiers : {e}")
        exit()

    # Initialisation du RecetteManager (pour la logique d'ingr√©dients/stock)
    recette_manager = RecetteManager(df_recettes, df_ingredients, df_ingredients_recettes)

    # Initialisation du G√©n√©rateur de Menus
    menu_generator = MenuGenerator(df_planning, df_recettes, df_menus, recette_manager)

    # D√©finir les pr√©f√©rences √† exclure (par exemple, des ingr√©dients ou types de plats que vous n'aimez pas)
    # C'est ici que vous pourriez ajouter une interface utilisateur pour collecter ces pr√©f√©rences
    preferences_a_exclure = ["lentilles", "ch√®vre"] # Exemple

    # G√©n√©ration du menu
    df_menu_genere = menu_generator.generer_menu(preferences_a_exclure)

    # Post-traitement et sauvegarde du menu g√©n√©r√©
    if not df_menu_genere.empty:
        # S'assurer que la colonne 'Nom' est de type string et convertir en titre
        df_menu_genere[COLONNE_NOM] = df_menu_genere[COLONNE_NOM].astype(str).apply(
            lambda x: unicodedata.normalize('NFKC', x).title()
        )
        # Supprimer 'N/A' si Nom Menu est 'Plat √† d√©finir'
        df_menu_genere.loc[df_menu_genere['Nom'] == 'Plat √Ä D√©finir', 'ID_Recette'] = ''

        # Ajout du r√©capitulatif des ingr√©dients
        logger.info("G√©n√©ration du r√©capitulatif des ingr√©dients et de la liste de courses.")
        liste_courses, ingredients_par_repas = recette_manager.generer_liste_courses(df_menu_genere, df_planning)

        # G√©n√©rer le contenu du fichier texte de r√©capitulatif
        contenu_fichier_recap_txt = []

        # R√©capitulatif par repas (d√©j√† tri√© par date dans le planning)
        contenu_fichier_recap_txt.append("=== R√©capitulatif des ingr√©dients par repas ===\n")
        # Trier les dates pour s'assurer de l'ordre chronologique
        dates_triees = sorted(ingredients_par_repas.keys(), key=lambda x: datetime.strptime(x, '%d/%m/%Y'))

        for date_repas in dates_triees:
            contenu_fichier_recap_txt.append(f"\n--- Le {date_repas} ---\n")
            for nom_repas, ingredients_details in ingredients_par_repas[date_repas].items():
                contenu_fichier_recap_txt.append(f"  Repas: {nom_repas}\n")
                for ing_detail in ingredients_details:
                    contenu_fichier_recap_txt.append(
                        f"    - {ing_detail['nom']} : N√©cessaire {ing_detail['qte_necessaire']:.2f} {ing_detail['unite']} "
                        f"(Stock: {ing_detail['qte_en_stock']:.2f}, A acheter: {ing_detail['qte_achetee']:.2f})\n"
                    )

        # Liste de courses finale
        contenu_fichier_recap_txt.append("\n=== LISTE DE COURSES FINALE ===\n")
        if liste_courses:
            # Tri par type de stock, puis par nom d'ingr√©dient
            ingredients_trier = sorted(
                liste_courses.items(),
                key=lambda item: (item[1]["type_stock"], item[0].lower())
            )
            current_type_stock = None
            for nom_ing, details in ingredients_trier:
                if details["type_stock"] != current_type_stock:
                    current_type_stock = details["type_stock"]
                    contenu_fichier_recap_txt.append(f"\n--- {current_type_stock.upper()} ---\n")
                contenu_fichier_recap_txt.append(f"- {nom_ing}: {details['quantite']:.2f} {details['unite']}\n")
        else:
            contenu_fichier_recap_txt.append("Aucun ingr√©dient √† acheter pour ce menu.\n")

        # Exporter les listes anti-gaspi
        contenu_fichier_recap_txt.append("\n=== INGR√âDIENTS √Ä CONSOMMER EN PRIORIT√â (Anti-Gaspi) ===\n")
        if recette_manager.anti_gaspi_ingredients:
            for ing_id, ing_nom in recette_manager.anti_gaspi_ingredients.items():
                # R√©cup√©rer la quantit√© en stock pour l'affichage
                ing_stock_df = recette_manager.stock_simule[recette_manager.stock_simule[COLONNE_ID_INGREDIENT].astype(str) == ing_id]
                if not ing_stock_df.empty:
                    qte_stock_anti_gaspi = ing_stock_df["Qte reste"].iloc[0]
                    unite_anti_gaspi = ing_stock_df["unit√©"].iloc[0]
                    contenu_fichier_recap_txt.append(f"- {ing_nom} ({qte_stock_anti_gaspi:.2f} {unite_anti_gaspi})\n")
                else:
                    contenu_fichier_recap_txt.append(f"- {ing_nom} (Quantit√© non trouv√©e)\n")
        else:
            contenu_fichier_recap_txt.append("Aucun ingr√©dient en stock √©lev√© √† consommer en priorit√©.\n")


        # Affichage direct du contenu pour Colab
        display(HTML("<h2>Fichier G√©n√©r√© : Menu_genere.csv</h2>"))
        display(df_menu_genere)

        display(HTML("<h2>Fichier G√©n√©r√© : r√©capitulatif_ingredients.txt</h2>"))
        display(HTML("<pre style='background-color:#f0f0f0; padding:10px; border-radius:5px;'>{}</pre>".format("".join(contenu_fichier_recap_txt))))


        # Sauvegarde des fichiers
        # Nettoyer les caract√®res potentiellement probl√©matiques dans les noms de colonnes avant exportation
        df_menu_genere.columns = df_menu_genere.columns.str.replace("[^a-zA-Z0-9_]", "", regex=True)

        if not df_menu_genere.empty:
            # Log du nombre de lignes avant tout traitement
            logger.info(f"Nombre de lignes totales g√©n√©r√©es : {len(df_menu_genere)}")
            # Formater les dates pour Notion au format YYYY-MM-DD HH:MM
            if 'Date' in df_menu_genere.columns:
                df_menu_genere['Date'] = pd.to_datetime(df_menu_genere['Date'], format="%d/%m/%Y %H:%M", errors='coerce').dt.strftime('%Y-%m-%d %H:%M')
            # Exporter uniquement les colonnes demand√©es
            colonnes_export = ["Date", "Participant(s)", "Nom"]
            df_menu_genere.to_csv(FICHIER_SORTIE_MENU_CSV, columns=colonnes_export, index=False, encoding="utf-8-sig")
            logger.info(f"Fichier CSV enregistr√© sous '{FICHIER_SORTIE_MENU_CSV}'")
        else:
            logger.warning(f"DataFrame menu vide. '{FICHIER_SORTIE_MENU_CSV}' non cr√©√©.")

        try:
            with open(FICHIER_SORTIE_LISTES_TXT, "w", encoding="utf-8") as f_txt:
                f_txt.writelines(contenu_fichier_recap_txt)
            logger.info(f"R√©capitulatif des ingr√©dients enregistr√© dans '{FICHIER_SORTIE_LISTES_TXT}'")
        except Exception as e:
            logger.error(f"Erreur √©criture du r√©capitulatif des ingr√©dients : {e}")

    else:
        logger.warning("Aucun menu n'a pu √™tre g√©n√©r√©.")
        print("Aucun menu n'a pu √™tre g√©n√©r√©. Veuillez v√©rifier vos donn√©es de planning et de recettes.")

```
