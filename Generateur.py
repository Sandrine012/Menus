
# -*- coding: utf-8 -*-
"""Générateur_complet_de_Menus_2.3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19OBFkinvdPXJy3omyKx6Al_hOVsdwGog

**Charger fichier Planning.csv**
"""

import pandas as pd
import csv
from notion_client import Client
from notion_client.errors import RequestTimeoutError, APIResponseError
import time
import httpx
import logging
from datetime import datetime, timedelta
import re
import unicodedata

# Configuration du logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Nom du fichier Planning.csv (assurez-vous qu'il se trouve dans le même répertoire que votre script)
planning_file_name = "Planning.csv"

try:
    logger.info(f"Tentative de chargement du fichier {planning_file_name}...")
    # Détection automatique du séparateur CSV
    df_planning = pd.read_csv(planning_file_name, sep=None, engine='python')
    logger.info(f"✅ Fichier {planning_file_name} chargé avec succès !")
    logger.info(df_planning.head())
except FileNotFoundError:
    logger.critical(f"❌ Erreur: Le fichier '{planning_file_name}' n'a pas été trouvé. Assurez-vous qu'il est dans le même répertoire que votre script.")
    raise RuntimeError(f"Fichier {planning_file_name} manquant.")
except Exception as e:
    logger.critical(f"❌ Erreur lors du chargement de {planning_file_name}: {e}")
    raise RuntimeError(f"Erreur de lecture du fichier {planning_file_name}.")

"""API Ingrédients"""

# --- PARAMÈTRES NOTION ---
notion = Client(auth="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")
database_id = "b23b048b67334032ac1ae4e82d308817"
csv_filename_ingredients = "Ingredients.csv" # Renommé pour éviter conflit
num_rows_to_extract = 1000  # Limite pour les tests, modifiable

batch_size = 25
api_timeout_seconds = 180
max_retries = 7

total_extracted = 0
next_cursor = None

def extract_property_value(prop):
    if not isinstance(prop, dict):
        return ""
    t = prop.get("type")
    if t == "title":
        return "".join([t.get("plain_text", "") for t in prop.get("title", [])])
    elif t == "rich_text":
        return "".join([t.get("plain_text", "") for t in prop.get("rich_text", [])])
    elif t == "multi_select":
        return ", ".join([opt.get("name", "") for opt in prop.get("multi_select", [])])
    elif t == "select":
        select_obj = prop.get("select")
        if select_obj is not None:
            return select_obj.get("name", "")
        return ""
    elif t == "number":
        return str(prop.get("number", ""))
    elif t == "checkbox":
        return str(prop.get("checkbox", ""))
    elif t == "date":
        date_obj = prop.get("date")
        if date_obj is not None:
            return date_obj.get("start", "")
        return ""
    elif t == "people":
        return ", ".join([person.get("name", "") for person in prop.get("people", [])])
    elif t == "relation":
        return ", ".join([rel.get("id", "") for rel in prop.get("relation", [])])
    elif t == "url":
        return prop.get("url", "")
    elif t == "email":
        return prop.get("email", "")
    elif t == "phone_number":
        return prop.get("phone_number", "")
    elif t == "formula":
        formula = prop.get("formula", {})
        if formula.get("type") == "string":
            return formula.get("string", "")
        elif formula.get("type") == "number":
            return str(formula.get("number", ""))
        elif formula.get("type") == "boolean":
            return str(formula.get("boolean", ""))
    elif t == "rollup":
        rollup = prop.get("rollup", {})
        if rollup.get("type") == "array":
            return ", ".join([
                str(item.get("plain_text", ""))
                for item in rollup.get("array", [])
            ])
        elif rollup.get("type") in ["number", "string"]:
            return str(rollup.get(rollup.get("type"), ""))
    return ""

try:
    with open(csv_filename_ingredients, 'w', newline='', encoding='utf-8') as csvfile:
        csv_writer = None
        # Retrieve database properties to determine headers
        db_properties = notion.databases.retrieve(database_id=database_id)["properties"]
        # Define the order of headers
        header = ["Page_ID", "Nom", "Type de stock", "unité", "Qte reste"]

        csv_writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL, dialect='excel')
        csv_writer.writerow(header)

        while total_extracted < num_rows_to_extract:
            try:
                results = notion.databases.query(
                    database_id=database_id,
                    start_cursor=next_cursor,
                    page_size=batch_size,
                    timeout=api_timeout_seconds,
                    filter={
                        "property": "Type de stock",
                        "select": {"equals": "Autre type"}
                    }
                )
                page_results = results.get("results", [])
                if not page_results:
                    logger.info("Aucun résultat retourné par l'API ou fin de la base de données atteinte.")
                    break

                for result in page_results:
                    if total_extracted >= num_rows_to_extract:
                        break
                    properties = result.get("properties", {})
                    
                    row_values = [result.get("id", "")]
                    row_values.append(extract_property_value(properties.get("Nom", {})))
                    row_values.append(extract_property_value(properties.get("Type de stock", {})))
                    row_values.append(extract_property_value(properties.get("unité", {})))
                    row_values.append(extract_property_value(properties.get("Qte reste", {})))
                    csv_writer.writerow(row_values)

                    total_extracted += 1

                next_cursor = results.get("next_cursor")
                if not next_cursor:
                    break
                time.sleep(1)
            except (httpx.TimeoutException, RequestTimeoutError) as e:
                logger.warning(f"Timeout détecté : {e}")
                time.sleep(10)
                continue
            except Exception as e:
                logger.exception(f"Erreur inattendue : {e}")
                break
    logger.info(f"Extraction terminée. {total_extracted} lignes exportées dans {csv_filename_ingredients}.")
except IOError as e:
    logger.error(f"Erreur d'écriture du fichier : {e}")


"""API Ingrédients_Recettes"""

# --- PARAMÈTRES NOTION ---
notion = Client(auth="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")
database_id_ingredients_recettes = "1d16fa46f8b2805b8377eba7bf668eb5" # Renommé pour éviter conflit
csv_filename_ingredients_recettes = "Ingredients_recettes.csv" # Renommé pour éviter conflit
num_rows_to_extract_ir = 2000  # Extraction de 2000 lignes max

batch_size_ir = 25
api_timeout_seconds_ir = 180

total_extracted_ir = 0
next_cursor_ir = None

def extract_property_value_ir(prop):
    if not isinstance(prop, dict):
        return ""
    t = prop.get("type")
    if t == "title":
        return "".join([t.get("plain_text", "") for t in prop.get("title", [])])
    elif t == "rich_text":
        return "".join([t.get("plain_text", "") for t in prop.get("rich_text", [])])
    elif t == "multi_select":
        return ", ".join([opt.get("name", "") for opt in prop.get("multi_select", [])])
    elif t == "select":
        select_obj = prop.get("select")
        if select_obj is not None:
            return select_obj.get("name", "")
        return ""
    elif t == "number":
        return str(prop.get("number", ""))
    elif t == "checkbox":
        return str(prop.get("checkbox", ""))
    elif t == "date":
        date_obj = prop.get("date")
        if date_obj is not None:
            return date_obj.get("start", "")
        return ""
    elif t == "people":
        return ", ".join([person.get("name", "") for person in prop.get("people", [])])
    elif t == "relation":
        return ", ".join([rel.get("id", "") for rel in prop.get("relation", [])])
    elif t == "url":
        return prop.get("url", "")
    elif t == "email":
        return prop.get("email", "")
    elif t == "phone_number":
        return prop.get("phone_number", "")
    elif t == "formula":
        formula = prop.get("formula", {})
        if formula.get("type") == "string":
            return formula.get("string", "")
        elif formula.get("type") == "number":
            return str(formula.get("number", ""))
        elif formula.get("type") == "boolean":
            return str(formula.get("boolean", ""))
    elif t == "rollup":
        rollup = prop.get("rollup", {})
        if rollup.get("type") == "array":
            return ", ".join([
                str(item.get("plain_text", ""))
                for item in rollup.get("array", [])
            ])
        elif rollup.get("type") in ["number", "string"]:
            return str(rollup.get(rollup.get("type"), ""))
    return ""

try:
    with open(csv_filename_ingredients_recettes, 'w', newline='', encoding='utf-8') as csvfile:
        header = ["Page_ID", "Qté/pers_s", "Ingrédient ok", "Type de stock f"]
        csv_writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL, dialect='excel')
        csv_writer.writerow(header)

        while total_extracted_ir < num_rows_to_extract_ir:
            results = notion.databases.query(
                database_id=database_id_ingredients_recettes,
                start_cursor=next_cursor_ir,
                page_size=batch_size_ir,
                timeout=api_timeout_seconds_ir,
                filter={
                    "property": "Type de stock f",
                    "formula": {"string": {"equals": "Autre type"}}
                }
            )
            page_results = results.get("results", [])
            if not page_results:
                logger.info("Aucun résultat trouvé avec le filtre 'Autre type'")
                break

            for result in page_results:
                if total_extracted_ir >= num_rows_to_extract_ir:
                    break
                properties = result.get("properties", {})

                # Récupérer l'ID de l'élément parent depuis la propriété "Elément parent"
                element_parent_property = properties.get("Elément parent", {})
                parent_id = ""

                # Vérifier le type de la propriété et extraire l'ID en conséquence
                if element_parent_property:
                    if element_parent_property.get("type") == "relation":
                        # Si c'est une relation, prendre le premier ID de la liste
                        relations = element_parent_property.get("relation", [])
                        if relations and len(relations) > 0:
                            parent_id = relations[0].get("id", "")
                    else:
                        # Si ce n'est pas une relation, extraire la valeur comme texte
                        parent_id = extract_property_value_ir(element_parent_property)

                # Si aucun parent_id n'est trouvé, utiliser l'ID de la page actuelle comme fallback
                if not parent_id:
                    parent_id = result.get("id", "")
                    logger.warning(f"Attention: Élément parent non trouvé pour {result.get('id')}, utilisation de l'ID de page comme fallback")

                qte_str = extract_property_value_ir(properties.get("Qté/pers_s", {}))
                try:
                    qte = float(qte_str.replace(",", "."))
                except (ValueError, AttributeError):
                    qte = 0
                if qte > 0:
                    row_values = [
                        parent_id,  # Utiliser l'ID de l'élément parent au lieu de l'ID de la page
                        qte_str,
                        extract_property_value_ir(properties.get("Ingrédient ok", {})),
                        extract_property_value_ir(properties.get("Type de stock f", {}))
                    ]
                    csv_writer.writerow(row_values)
                    total_extracted_ir += 1

            next_cursor_ir = results.get("next_cursor")
            if not next_cursor_ir:
                break
            time.sleep(1)
    logger.info(f"Extraction terminée. {total_extracted_ir} lignes exportées dans {csv_filename_ingredients_recettes}.")
except Exception as e:
    logger.error(f"Erreur : {e}")

"""**API Recettes**"""

# ========== CONFIGURATION NOTION ==========
NOTION_API_KEY = "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"
DATABASE_ID_RECETTES    = "1d16fa46f8b2805b8377eba7bf668eb5" # Renommé pour éviter conflit
SAISON_FILTRE  = "Printemps"

notion = Client(auth=NOTION_API_KEY)
logger.info("Client Notion initialisé.")
logger.info(f"ID de la base de données cible : {DATABASE_ID_RECETTES}")
if SAISON_FILTRE:
    logger.info(f"Saison pour le filtre dynamique : {SAISON_FILTRE}")

# ========== PARAMÈTRES D'EXTRACTION ==========
csv_filename_recettes         = "Recettes.csv" # Renommé pour éviter conflit
num_rows_to_extract_recettes  = 400
batch_size_recettes           = 50
max_retries_recettes          = 3
retry_delay_initial_recettes  = 5

# ========== DÉFINITION DU FILTRE (Noms vérifiés par rapport à votre liste) ==========
filter_conditions = [
    {"property": "Elément parent", "relation": {"is_empty": True}},
    {
        "or": [
            {"property": "Saison", "multi_select": {"contains": "Toute l'année"}},
            *([{"property": "Saison", "multi_select": {"contains": SAISON_FILTRE}}] if SAISON_FILTRE else []),
            {"property": "Saison", "multi_select": {"is_empty": True}}
        ]
    },
    {
        "or": [
            {"property": "Type_plat", "multi_select": {"contains": "Salade"}},
            {"property": "Type_plat", "multi_select": {"contains": "Soupe"}},
            {"property": "Type_plat", "multi_select": {"contains": "Plat"}}
        ]
    }
]
filter_recettes_api = {"and": filter_conditions} # Renommé pour éviter conflit
logger.info(f"Filtre API Notion : {filter_recettes_api}")


# ========== EN-TÊTE CSV (modifiée pour exclure Ingredients_quantite) ==========
header_csv_recettes = [ # Renommé pour éviter conflit
    "Page_ID", "Nom", "ID_Recette", "Saison",
    "Calories", "Proteines", "Temps_total", "Aime_pas_princip",
    "Type_plat", "Transportable"
]

# ========== FONCTION D'EXTRACTION DE PROPRIÉTÉS (Identique à la version précédente) ==========
def get_property_value(prop_data, notion_prop_name_for_log, expected_format_key):
    if not prop_data: return ""
    prop_type = prop_data.get("type")

    try:
        if expected_format_key == "title":
            return "".join(t.get("text", {}).get("content", "") for t in prop_data.get("title", []))
        elif expected_format_key == "rollup_text_concat":
            if prop_type == "rollup":
                arr = prop_data.get("rollup", {}).get("array", [])
                values = []
                for item in arr:
                    if item.get("type") == "rich_text": values.append("".join(t.get("plain_text", "") for t in item.get("rich_text", [])))
                    elif item.get("type") == "title": values.append("".join(t.get("text", {}).get("content", "") for t in item.get("title", [])))
                return ", ".join(filter(None, values))
            return ""
        elif expected_format_key == "unique_id_or_text":
            if prop_type == "unique_id":
                uid = prop_data.get("unique_id", {}); p, n = uid.get("prefix"), uid.get("number")
                return f"{p}-{n}" if p and n is not None else (str(n) if n is not None else "")
            elif prop_type == "title": return get_property_value(prop_data, notion_prop_name_for_log, "title")
            elif prop_type == "rich_text": return get_property_value(prop_data, notion_prop_name_for_log, "rich_text_plain")
            return ""
        elif expected_format_key == "rich_text_plain":
             return "".join(t.get("plain_text", "") for t in prop_data.get("rich_text", []))
        elif expected_format_key == "multi_select_comma_separated":
            if prop_type == "multi_select":
                return ", ".join(filter(None, [o.get("name", "") for o in prop_data.get("multi_select", [])]))
            return ""
        elif expected_format_key == "number_to_string_or_empty":
            if prop_type == "number": num = prop_data.get("number"); return str(num) if num is not None else ""
            return ""
        elif expected_format_key == "formula_number_or_string_or_empty":
            if prop_type == "formula":
                fo = prop_data.get("formula", {}); ft = fo.get("type")
                if ft == "number": num = fo.get("number"); return str(num) if num is not None else ""
                elif ft == "string": return fo.get("string", "")
            return ""
        elif expected_format_key == "rollup_single_number_or_empty":
             if prop_type == "rollup":
                ro = prop_data.get("rollup", {}); rt = ro.get("type")
                if rt == "number": num = ro.get("number"); return str(num) if num is not None else ""
                elif rt == "array":
                    arr = ro.get("array", [])
                    if arr:
                        item = arr[0]; it = item.get("type")
                        if it == "number": num = item.get("number"); return str(num) if num is not None else ""
                        elif it == "formula":
                             fi = item.get("formula", {}); fit = fi.get("type")
                             if fit == "number": num = fi.get("number"); return str(num) if num is not None else ""
             return ""
        elif expected_format_key == "rollup_formula_string_dots_comma_separated":
            if prop_type == "rollup":
                arr = prop_data.get("rollup", {}).get("array", [])
                vals = []
                for item in arr:
                    if item.get("type") == "formula":
                        fo = item.get("formula", {}); ft = fo.get("type")
                        if ft == "string": sv = fo.get("string"); vals.append(sv if sv and sv.strip() else ".")
                        else: vals.append(".")
                    else: vals.append(".")
                return ", ".join(vals)
            return ""
        elif expected_format_key == "select_to_oui_empty":
            if prop_type == "select":
                so = prop_data.get("select"); return "Oui" if so and so.get("name", "").lower() == "oui" else ""
            elif prop_type == "checkbox": return "Oui" if prop_data.get("checkbox", False) else ""
            return ""
    except Exception as e:
        logger.error(f"EXC Formatage: '{notion_prop_name_for_log}' (format: {expected_format_key}): {e}", exc_info=False)
        return "ERREUR_FORMAT"
    return ""

# ========== PROCESSUS D'EXTRACTION ET ÉCRITURE CSV ==========
total_extracted_and_written_recettes = 0 # Renommé pour éviter conflit
next_cursor_recettes = None # Renommé pour éviter conflit
start_time_recettes = time.time() # Renommé pour éviter conflit

csv_to_notion_mapping = {
    "Page_ID":              (None, "page_id_special"),
    "Nom":                  ("Nom_plat", "title"),
    "ID_Recette":           ("ID_Recette", "unique_id_or_text"),
    "Saison":               ("Saison", "multi_select_comma_separated"),
    "Calories":             ("Calories Recette", "rollup_single_number_or_empty"),
    "Proteines":            ("Proteines Recette", "rollup_single_number_or_empty"),
    "Temps_total":          ("Temps_total", "formula_number_or_string_or_empty"),
    "Aime_pas_princip":     ("Aime_pas_princip", "rollup_formula_string_dots_comma_separated"),
    "Type_plat":            ("Type_plat", "multi_select_comma_separated"),
    "Transportable":        ("Transportable", "select_to_oui_empty")
}

logger.info(f"Ouverture du fichier '{csv_filename_recettes}' pour écriture.")
with open(csv_filename_recettes, "w", newline="", encoding="utf-8") as csvfile:
    writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL)
    writer.writerow(header_csv_recettes)

    pages_retrieved_from_api_total_recettes = 0 # Renommé pour éviter conflit

    while total_extracted_and_written_recettes < num_rows_to_extract_recettes:
        retries = 0
        current_retry_delay = retry_delay_initial_recettes

        try:
            query_params = {"database_id": DATABASE_ID_RECETTES, "filter": filter_recettes_api, "page_size": batch_size_recettes}
            if next_cursor_recettes: query_params["start_cursor"] = next_cursor_recettes

            logger.info(f"Appel API Notion (Curseur: {next_cursor_recettes or 'aucun'}).")
            response = notion.databases.query(**query_params)

            pages_batch = response.get("results", [])
            pages_retrieved_from_api_total_recettes += len(pages_batch)
            logger.info(f"API a retourné {len(pages_batch)} pages pour ce lot. (Total API: {pages_retrieved_from_api_total_recettes})")

            next_cursor_recettes = response.get("next_cursor")

        except (RequestTimeoutError, httpx.TimeoutException, httpx.ReadTimeout) as e:
            retries += 1; logger.warning(f"Timeout API (tentative {retries}/{max_retries_recettes}). Attente {current_retry_delay}s...")
            if retries >= max_retries_recettes: logger.error(f"Max timeouts atteints. Abandon."); break
            time.sleep(current_retry_delay); current_retry_delay = min(current_retry_delay*2, 60); continue
        except APIResponseError as e:
            logger.error(f"Erreur API Notion: {e.code} - {e.message}.")
            if e.code in ["validation_error", "invalid_json", "unauthorized", "restricted_resource"]: logger.error("Erreur API non récupérable. Abandon."); break
            retries += 1; logger.warning(f"Erreur API (tentative {retries}/{max_retries_recettes}). Attente {current_retry_delay}s...")
            if retries >= max_retries_recettes: logger.error(f"Max erreurs API atteintes. Abandon."); break
            time.sleep(current_retry_delay); current_retry_delay = min(current_retry_delay*2, 60); continue
        except Exception as e:
            logger.error(f"Erreur inattendue: {e}", exc_info=True); break

        if not pages_batch:
            if pages_retrieved_from_api_total_recettes == 0:
                 logger.critical("!!! AUCUNE PAGE RETOURNÉE PAR L'API AVEC LE FILTRE ACTUEL !!!")
                 logger.critical("Cause probable : Noms de propriétés incorrects dans le filtre OU conditions du filtre trop restrictives OU permissions de l'intégration.")
                 logger.critical(f"Filtre utilisé : {filter_recettes_api}")
            else:
                 logger.info("Plus de pages à récupérer de l'API.")
            break

        rows_written_this_batch = 0
        for page in pages_batch:
            page_props_raw = page.get("properties", {})
            row_to_write = []
            for csv_col_name in header_csv_recettes:
                notion_prop_name_key, expected_format_key = csv_to_notion_mapping[csv_col_name]
                if csv_col_name == "Page_ID": row_to_write.append(page.get("id", ""))
                else:
                    raw_prop_data = page_props_raw.get(notion_prop_name_key)
                    if raw_prop_data is None and notion_prop_name_key is not None:
                         logger.warning(f"Propriété Notion '{notion_prop_name_key}' (pour CSV '{csv_col_name}') non trouvée dans la page ID {page.get('id')}. Clés dispo: {list(page_props_raw.keys())}")
                    value = get_property_value(raw_prop_data, notion_prop_name_key, expected_format_key)
                    row_to_write.append(value)

            writer.writerow(row_to_write)
            rows_written_this_batch +=1
            total_extracted_and_written_recettes += 1
            if total_extracted_and_written_recettes >= num_rows_to_extract_recettes: break

        logger.info(f"{rows_written_this_batch} lignes écrites au CSV pour ce lot. Total écrit: {total_extracted_and_written_recettes}.")

        if not next_cursor_recettes or total_extracted_and_written_recettes >= num_rows_to_extract_recettes:
            logger.info("Fin (plus de pages ou limite atteinte).")
            break
        time.sleep(0.35)

duration_recettes = time.time() - start_time_recettes
logger.info(f"Terminé en {duration_recettes:.2f}s. {total_extracted_and_written_recettes} recettes écrites dans '{csv_filename_recettes}'.")
if total_extracted_and_written_recettes == 0 :
    if pages_retrieved_from_api_total_recettes == 0:
        logger.error("RÉSUMÉ FINAL : AUCUNE page récupérée de l'API ET AUCUNE ligne écrite. Le problème est très certainement le FILTRE API ou les PERMISSIONS.")

"""**API Menus**"""

# --- VOS PARAMETRES NOTION ---
notion = Client(auth="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")
database_id_menus = "9025cfa1c18d4501a91dbeb1b10b48bd"  # ID de la base de données corrigé
logger.info("Client Notion initialisé.")
logger.info(f"ID de la base de données: {database_id_menus}")
# --- FIN PARAMETRES NOTION ---

# Nom du fichier CSV de sortie
csv_filename_menus = "Menus.csv" # Renommé pour éviter conflit

# Nombre de lignes VALIDES à extraire
num_rows_to_extract_menus = 100000 # Renommé pour éviter conflit

# --- NOMS DES PROPRIÉTÉS NOTION (À MODIFIER ICI SI NÉCESSAIRE) ---
nom_menu_property_name = "Nom Menu"
recette_property_name = "Recette"
date_property_name = "Date"
# --- FIN DES NOMS DE PROPRIÉTÉS NOTION ---

# --- PARAMÈTRES AJUSTÉS ---
next_cursor_menus = None # Renommé pour éviter conflit
batch_size_menus = 25 # Renommé pour éviter conflit
max_retries_menus = 7 # Renommé pour éviter conflit
retry_delay_menus = 10 # Le délai initial # Renommé pour éviter conflit
retries_menus = 0 # Renommé pour éviter conflit
api_timeout_seconds_menus = 180 # Gardons 3 minutes pour l'instant # Renommé pour éviter conflit
# --- FIN PARAMÈTRES AJUSTÉS ---

total_extracted_menus = 0 # Renommé pour éviter conflit
start_time_global_menus = time.time() # Renommé pour éviter conflit

logger.info(f"Début de l'extraction de jusqu'à {num_rows_to_extract_menus} menus ({nom_menu_property_name}, {recette_property_name}, {date_property_name}) vers '{csv_filename_menus}'...")
logger.info(f"Paramètres API: batch_size={batch_size_menus}, timeout={api_timeout_seconds_menus}, max_retries={max_retries_menus}")

try:
    # --- TEST DE CONNEXION INITIALE À LA BASE DE DONNÉES ---
    try:
        database_info = notion.databases.retrieve(database_id_menus)
        logger.info(f"Informations de la base de données récupérées avec succès: {database_info.get('title')}")
    except Exception as e:
        logger.error(f"Erreur lors de la récupération des informations de la base de données initiale. Vérifiez votre jeton et l'ID de la base de données : {e}")
        exit()
    # --- FIN TEST DE CONNEXION INITIALE ---

    with open(csv_filename_menus, 'w', newline='', encoding='utf-8') as csvfile:
        csv_writer = csv.writer(csvfile, quoting=csv.QUOTE_MINIMAL, dialect='excel')
        header = [nom_menu_property_name, recette_property_name, date_property_name]
        csv_writer.writerow(header)

        while total_extracted_menus < num_rows_to_extract_menus:
            page_start_time = time.time()
            try:
                request_batch_size = batch_size_menus
                logger.debug(f"Demande à Notion: start_cursor={next_cursor_menus}, page_size={request_batch_size}")

                results = notion.databases.query(
                    database_id=database_id_menus,
                    start_cursor=next_cursor_menus,
                    page_size=request_batch_size,
                    filter={
                        "and": [
                            {"property": recette_property_name, "relation": {"is_not_empty": True}},
                        ]
                    },
                    timeout=api_timeout_seconds_menus
                )

                retries_menus = 0
                retry_delay_menus = 10

                page_results = results.get("results", [])
                if not page_results:
                    logger.info("Aucun résultat retourné par l'API ou fin de la base de données atteinte.")
                    break

                logger.info(f"Reçu {len(page_results)} menus de Notion. Traitement ({nom_menu_property_name}, {recette_property_name}, {date_property_name})...")
                page_valid_count = 0

                for result in page_results:
                    if total_extracted_menus >= num_rows_to_extract_menus:
                        break

                    row_values = []
                    properties = result.get("properties", {})

                    # 1. Nom Menu
                    nom_menu_value = ""
                    if nom_menu_property_name in properties:
                        name_property = properties[nom_menu_property_name]
                        nom_menu_value = "".join([text.get("plain_text", "") for text in name_property.get("title", []) or name_property.get("rich_text", [])])
                    row_values.append(nom_menu_value.strip())

                    # 2. Recette (Gestion de la relation - Extraction des IDs)
                    recette_value = ""
                    if recette_property_name in properties:
                        prop = properties[recette_property_name]
                        if prop["type"] == "relation" and prop["relation"]:
                            recette_value = ", ".join([relation["id"] for relation in prop["relation"]])
                        elif prop["type"] == "rollup" and prop["rollup"]:
                            rollup_data = prop["rollup"]
                            if rollup_data.get("type") == "array" and rollup_data.get("array"):
                                recette_ids = []
                                for item in rollup_data["array"]:
                                    if item.get("id"):
                                        recette_ids.append(item["id"])
                                    elif item.get("relation"):
                                        recette_ids.extend([rel.get("id") for rel in item["relation"] if rel.get("id")])
                                recette_value = ", ".join(recette_ids)
                    row_values.append(recette_value)

                    # 3. Date (Formatage de la date)
                    date_value = ""
                    if date_property_name in properties:
                        date_property = properties[date_property_name]
                        if date_property["type"] == "date" and date_property.get("date") and date_property["date"].get("start"):
                            date_str = date_property["date"]["start"]
                            date_object = datetime.fromisoformat(date_str.replace('Z', '+00:00'))
                            date_value = date_object.strftime('%Y-%m-%d')
                    row_values.append(date_value)

                    csv_writer.writerow(row_values)
                    total_extracted_menus += 1
                    page_valid_count += 1

                page_end_time = time.time()
                logger.info(f"Page traitée en {page_end_time - page_start_time:.2f} sec. {page_valid_count} menus ajoutés (Total: {total_extracted_menus}/{num_rows_to_extract_menus}).")

                if total_extracted_menus >= num_rows_to_extract_menus:
                    logger.info(f"Limite de {num_rows_to_extract_menus} menus atteinte.")
                    break
                next_cursor_menus = results.get("next_cursor")
                if not next_cursor_menus:
                    logger.info("Fin des pages retournées par l'API (next_cursor est None).")
                    break

                logger.info(f"Passage à la page suivante (next_cursor: {str(next_cursor_menus)[:10]}...).")
                time.sleep(1)

            except (httpx.TimeoutException, RequestTimeoutError) as e:
                retries_menus += 1
                logger.warning(f"Timeout détecté ({type(e).__name__}). Tentative {retries_menus}/{max_retries_menus}...")
                if retries_menus >= max_retries_menus:
                    logger.error(f"Nombre maximum de tentatives atteint ({max_retries_menus}) après Timeout. Abandon.")
                    break

                logger.warning(f"Attente de {retry_delay_menus} secondes avant la nouvelle tentative...")
                time.sleep(retry_delay_menus)
                retry_delay_menus *= 2
                continue

            except Exception as e:
                logger.exception(f"Une erreur inattendue et non liée au timeout est survenue pendant la boucle : {e}")
                break

except IOError as e:
    logger.error(f"Erreur: Impossible d'écrire dans le fichier '{csv_filename_menus}'. {e}")
except Exception as e:
    logger.exception(f"Erreur générale avant la boucle principale : {e}")

end_time_global_menus = time.time()
total_duration_menus = end_time_global_menus - start_time_global_menus
final_message_menus = f"Extraction terminée en {total_duration_menus:.2f} secondes. {total_extracted_menus} menus ({nom_menu_property_name}, {recette_property_name}, {date_property_name}) "
if total_extracted_menus < num_rows_to_extract_menus and next_cursor_menus is None:
    final_message_menus += f"trouvés (toute la base de données a été parcourue) et sauvegardés dans '{csv_filename_menus}'"
elif total_extracted_menus < num_rows_to_extract_menus:
    final_message_menus += f"trouvés (moins que les {num_rows_to_extract_menus} demandées, possible arrêt prématuré ou erreur) et sauvegardés dans '{csv_filename_menus}'"
else:
    final_message_menus += f"sauvegardés dans '{csv_filename_menus}'"
print(final_message_menus)
logger.info(final_message_menus)

"""**Générateur de Menus**"""

# Constantes globales
NB_JOURS_ANTI_REPETITION = 42
# FICHIER_PLANNING est déjà défini et chargé
FICHIER_RECETTES = csv_filename_recettes
FICHIER_MENUS = csv_filename_menus # Pour l'historique
FICHIER_INGREDIENTS = csv_filename_ingredients
FICHIER_INGREDIENTS_RECETTES = csv_filename_ingredients_recettes
FICHIER_SORTIE_MENU_CSV = "Menu_genere.csv"
FICHIER_SORTIE_LISTES_TXT = "recapitulatif_ingredients.txt" # Pour toutes les listes

COLONNE_NOM = "Nom"
COLONNE_TEMPS_TOTAL = "Temps_total"
COLONNE_ID_RECETTE = "Page_ID" # Utilisé comme ID pour Recettes et Ingredients_recettes
COLONNE_ID_INGREDIENT = "Page_ID" # Utilisé comme ID pour Ingredients
COLONNE_AIME_PAS_PRINCIP = "Aime_pas_princip"

VALEUR_DEFAUT_TEMPS_PREPARATION = 10
TEMPS_MAX_EXPRESS = 20
TEMPS_MAX_RAPIDE = 30
REPAS_EQUILIBRE = 700

# Logging déjà configuré globalement

def verifier_colonnes(df, colonnes_attendues, nom_fichier=""):
    colonnes_manquantes = [col for col in colonnes_attendues if col not in df.columns]
    if colonnes_manquantes:
        raise ValueError(f"Colonnes manquantes dans {nom_fichier}: {colonnes_manquantes}")

class RecetteManager:
    def __init__(self, df_recettes, df_ingredients, df_ingredients_recettes):
        self.df_recettes = df_recettes.copy()
        # S'assurer que Page_ID est l'index si la colonne existe
        if COLONNE_ID_RECETTE in self.df_recettes.columns and not self.df_recettes.index.name == COLONNE_ID_RECETTE:
            self.df_recettes = self.df_recettes.set_index(COLONNE_ID_RECETTE, drop=False)

        self.df_ingredients_initial = df_ingredients.copy() # Stock initial avec noms, etc. Ne sera pas modifié.
        self.df_ingredients_recettes = df_ingredients_recettes.copy()

        self.stock_simule = self.df_ingredients_initial.copy() # Copie pour la simulation
        if "Qte reste" in self.stock_simule.columns:
            self.stock_simule["Qte reste"] = pd.to_numeric(self.stock_simule["Qte reste"], errors='coerce').fillna(0).astype(float)
        else:
            logger.error("'Qte reste' manquante dans df_ingredients pour stock_simule.")
            self.stock_simule["Qte reste"] = 0.0
        self.anti_gaspi_ingredients = self._trouver_ingredients_stock_eleve()

    def get_ingredients_for_recipe(self, recette_id_str):
        try:
            recette_id_str = str(recette_id_str)
            ingredients = self.df_ingredients_recettes[
                self.df_ingredients_recettes[COLONNE_ID_RECETTE].astype(str) == recette_id_str
            ][["Ingrédient ok", "Qté/pers_s"]].to_dict('records')
            if not ingredients:
                logger.debug(f"Aucun ingrédient trouvé pour recette {recette_id_str} dans df_ingredients_recettes")
            return ingredients
        except Exception as e:
            logger.error(f"Erreur récupération ingrédients pour {recette_id_str} : {e}")
            return []

    def _trouver_ingredients_stock_eleve(self):
        seuil_gr = 100
        seuil_pc = 1
        ingredients_stock = {}
        if not all(col in self.stock_simule.columns for col in ["Qte reste", "unité", COLONNE_ID_INGREDIENT, "Nom"]):
            logger.warning("Colonnes manquantes dans stock_simule pour _trouver_ingredients_stock_eleve.")
            return {}

        for _, row in self.stock_simule.iterrows():
            try:
                qte = float(str(row["Qte reste"]).replace(",", "."))
                unite = str(row["unité"]).lower()
                page_id = str(row[COLONNE_ID_INGREDIENT])

                if (unite in ["gr", "g", "ml", "cl"] and qte >= seuil_gr) or \
                   (unite in ["pc", "tranches"] and qte >= seuil_pc):
                    ingredients_stock[page_id] = row["Nom"]
            except (ValueError, KeyError) as e:
                logger.debug(f"Erreur dans _trouver_ingredients_stock_eleve pour ligne {row.get('Nom', 'ID inconnu')}: {e}")
                continue
        return ingredients_stock

    def recette_utilise_ingredient_anti_gaspi(self, recette_id_str):
        try:
            ingredients = self.get_ingredients_for_recipe(recette_id_str)
            return any(str(ing.get("Ingrédient ok")) in self.anti_gaspi_ingredients for ing in ingredients if ing.get("Ingrédient ok"))
        except Exception as e:
            logger.error(f"Erreur dans recette_utilise_ingredient_anti_gaspi pour {recette_id_str}: {e}")
            return False

    def calculer_quantite_necessaire(self, recette_id_str, nb_personnes):
        ingredients_necessaires = {}
        try:
            ingredients_recette = self.get_ingredients_for_recipe(recette_id_str)
            if not ingredients_recette:
                return {}

            for ing in ingredients_recette:
                try:
                    ing_id = str(ing.get("Ingrédient ok"))
                    if not ing_id or ing_id.lower() in ['nan', 'none', '']:
                        continue
                    qte_str = str(ing.get("Qté/pers_s", "0")).replace(',', '.')
                    qte_par_personne = float(qte_str)
                    ingredients_necessaires[ing_id] = qte_par_personne * nb_personnes
                except (ValueError, TypeError, KeyError) as e:
                    logger.debug(f"Erreur calcul quantité ingrédient {ing.get('Ingrédient ok')} pour recette {recette_id_str}: {e}. Qté str: '{ing.get('Qté/pers_s')}'")
                    continue
            return ingredients_necessaires
        except Exception as e:
            logger.error(f"Erreur globale calcul_quantite_necessaire pour {recette_id_str}: {e}")
            return {}

    def evaluer_disponibilite_et_manquants(self, recette_id_str, nb_personnes):
        """
        Évalue la disponibilité et identifie les quantités manquantes pour une recette.
        Retourne: score_moyen_dispo, pourcentage_dispo, dict_ingredients_manquants {ing_id: qte_manquante}
        """
        ingredients_necessaires = self.calculer_quantite_necessaire(recette_id_str, nb_personnes)
        if not ingredients_necessaires:
            return 0, 0, {}

        total_ingredients_definis = len(ingredients_necessaires)
        ingredients_disponibles_compteur = 0
        score_total_dispo = 0
        ingredients_manquants = {}

        for ing_id, qte_necessaire in ingredients_necessaires.items():
            ing_id_str = str(ing_id)
            ing_stock_df = self.stock_simule[self.stock_simule[COLONNE_ID_INGREDIENT].astype(str) == ing_id_str]
            qte_en_stock = 0.0
            if not ing_stock_df.empty:
                try:
                    qte_en_stock = float(ing_stock_df["Qte reste"].iloc[0])
                except (ValueError, IndexError, KeyError) as e:
                    logger.error(f"Erreur lecture stock pour {ing_id_str} rec {recette_id_str}: {e}")
            else:
                logger.debug(f"Ingrédient {ing_id_str} (recette {recette_id_str}) non trouvé dans stock_simule.")

            ratio_dispo = 0.0
            if qte_necessaire > 0:
                ratio_dispo = min(1.0, qte_en_stock / qte_necessaire)

            score_total_dispo += ratio_dispo
            if ratio_dispo >= 1.0:
                ingredients_disponibles_compteur += 1
            else:
                qte_manquante = max(0, qte_necessaire - qte_en_stock)
                ingredients_manquants[ing_id_str] = qte_manquante

        score_moyen_dispo = score_total_dispo / total_ingredients_definis if total_ingredients_definis > 0 else 0
        pourcentage_dispo = (ingredients_disponibles_compteur / total_ingredients_definis) * 100 if total_ingredients_definis > 0 else 0

        return score_moyen_dispo, pourcentage_dispo, ingredients_manquants

    def ajuster_stock_simule(self, recette_id_str, nb_personnes):
        ingredients_necessaires = self.calculer_quantite_necessaire(recette_id_str, nb_personnes)
        for ing_id, qte_necessaire in ingredients_necessaires.items():
            ing_id_str = str(ing_id)
            idx = self.stock_simule[self.stock_simule[COLONNE_ID_INGREDIENT].astype(str) == ing_id_str].index
            if not idx.empty:
                self.stock_simule.loc[idx, "Qte reste"] -= qte_necessaire
                self.stock_simule.loc[idx, "Qte reste"] = self.stock_simule.loc[idx, "Qte reste"].apply(lambda x: max(0, x))
            else:
                logger.warning(f"Ingrédient {ing_id_str} de la recette {recette_id_str} non trouvé dans le stock simule pour ajustement.")

    def _recuperer_nom_ingredient(self, ingredient_id):
        if not (COLONNE_ID_INGREDIENT in self.df_ingredients_initial.columns and "Nom" in self.df_ingredients_initial.columns):
            logger.error(f"Colonnes essentielles manquantes dans df_ingredients_initial: '{COLONNE_ID_INGREDIENT}' ou 'Nom'.")
            return f"Nom inconnu ({ingredient_id})"

        try:
            ingredient_info = self.df_ingredients_initial[
                self.df_ingredients_initial[COLONNE_ID_INGREDIENT].astype(str) == str(ingredient_id)
            ]
            if not ingredient_info.empty:
                return ingredient_info["Nom"].iloc[0]
        except Exception as e:
            logger.error(f"Erreur lors de la récupération du nom pour l'ingrédient ID {ingredient_id}: {e}")
        return f"Nom inconnu ({ingredient_id})"

    def generer_liste_courses(self, menu_genere_df, planning_df):
        logger.info("Début de la génération de la liste de courses.")
        liste_courses = {}
        ingredients_par_repas = {}

        df_recettes_temp = self.df_recettes.rename(columns={"ID_Recette": "Recette ID"})

        menu_avec_ids = pd.merge(
            menu_genere_df,
            df_recettes_temp[[COLONNE_NOM, "Recette ID"]].drop_duplicates(subset=[COLONNE_NOM]),
            on=COLONNE_NOM,
            how='left'
        )

        menu_avec_ids = pd.merge(
            menu_avec_ids,
            planning_df[['Date', 'Participant(s)']],
            on='Date',
            how='left'
        )
        menu_avec_ids['Participant(s)'] = pd.to_numeric(menu_avec_ids['Participant(s)'], errors='coerce').fillna(0).astype(int)

        if 'Recette ID' not in menu_avec_ids.columns or menu_avec_ids['Recette ID'].isnull().all():
            logger.error("La colonne 'Recette ID' est manquante ou vide après jointure. Vérifiez le nom de colonne et les données de Recettes.csv.")
            return {}, {}

        for index, row in menu_avec_ids.iterrows():
            recette_id = str(row["Recette ID"])
            nb_personnes = row["Participant(s)"]
            date_repas = row["Date"]
            nom_repas = row[COLONNE_NOM]

            logger.debug(f"Traitement du repas '{nom_repas}' du {date_repas} pour {nb_personnes} personnes.")

            ingredients_necessaires = self.calculer_quantite_necessaire(recette_id, nb_personnes)
            if not ingredients_necessaires:
                logger.warning(f"Aucun ingrédient nécessaire trouvé pour la recette '{nom_repas}' (ID: {recette_id}).")
                continue

            for ing_id, qte_necessaire in ingredients_necessaires.items():
                nom_ingredient = self._recuperer_nom_ingredient(ing_id)
                ing_info_df = self.df_ingredients_initial[self.df_ingredients_initial[COLONNE_ID_INGREDIENT].astype(str) == str(ing_id)]

                qte_en_stock = 0.0
                unite = "unité"
                type_stock = "Inconnu"

                if not ing_info_df.empty:
                    unite = ing_info_df["unité"].iloc[0]
                    type_stock = ing_info_df["Type de stock"].iloc[0]
                    qte_en_stock = float(ing_info_df["Qte reste"].iloc[0])

                qte_achetee = 0.0
                if qte_necessaire > qte_en_stock:
                    qte_achetee = qte_necessaire - qte_en_stock
                    logger.debug(f"Besoin d'acheter {qte_achetee:.2f} {unite} de {nom_ingredient} (stock: {qte_en_stock}, nécessaire: {qte_necessaire}).")

                if qte_achetee > 0:
                    if nom_ingredient not in liste_courses:
                        liste_courses[nom_ingredient] = {"quantite": 0.0, "unite": unite, "type_stock": type_stock}
                    liste_courses[nom_ingredient]["quantite"] += qte_achetee
                else:
                    logger.debug(f"Ingrédient {nom_ingredient} suffisant en stock. Pas d'achat.")


                if date_repas not in ingredients_par_repas:
                    ingredients_par_repas[date_repas] = {}
                if nom_repas not in ingredients_par_repas[date_repas]:
                    ingredients_par_repas[date_repas][nom_repas] = []
                ingredients_par_repas[date_repas][nom_repas].append({
                    "nom": nom_ingredient,
                    "qte_necessaire": qte_necessaire,
                    "unite": unite,
                    "qte_en_stock": qte_en_stock,
                    "qte_achetee": qte_achetee
                })

        logger.info("Génération de la liste de courses terminée.")
        return liste_courses, ingredients_par_repas

class MenuGenerator:
    def __init__(self, df_planning, df_recettes, df_menus_historique, recette_manager):
        self.df_planning = df_planning.copy()
        self.df_recettes = df_recettes.copy()
        self.df_menus_historique = df_menus_historique.copy()
        self.recette_manager = recette_manager

        self._preparer_donnees()

    def _preparer_donnees(self):
        # Planning
        self.df_planning['Date'] = pd.to_datetime(self.df_planning['Date'], format='%d/%m/%Y', errors='coerce')
        self.df_planning = self.df_planning.dropna(subset=['Date'])
        self.df_planning['Participant(s)'] = pd.to_numeric(self.df_planning['Participant(s)'], errors='coerce').fillna(1).astype(int)

        # Recettes: Assurez-vous que les colonnes existent avant d'y accéder
        colonnes_recettes_req = [COLONNE_NOM, COLONNE_TEMPS_TOTAL, COLONNE_ID_RECETTE, "Calories", "Proteines", "Type_plat", COLONNE_AIME_PAS_PRINCIP, "Transportable"]
        verifier_colonnes(self.df_recettes, colonnes_recettes_req, FICHIER_RECETTES)

        self.df_recettes = self.df_recettes.copy()
        self.df_recettes[COLONNE_TEMPS_TOTAL] = pd.to_numeric(self.df_recettes[COLONNE_TEMPS_TOTAL], errors='coerce').fillna(VALEUR_DEFAUT_TEMPS_PREPARATION)
        self.df_recettes[COLONNE_ID_RECETTE] = self.df_recettes[COLONNE_ID_RECETTE].astype(str)
        self.df_recettes['Calories'] = pd.to_numeric(self.df_recettes['Calories'], errors='coerce').fillna(0)
        self.df_recettes['Proteines'] = pd.to_numeric(self.df_recettes['Proteines'], errors='coerce').fillna(0)
        # Gérer la colonne 'Aime_pas_princip' : la convertir en string et remplacer NaN par vide
        self.df_recettes[COLONNE_AIME_PAS_PRINCIP] = self.df_recettes[COLONNE_AIME_PAS_PRINCIP].astype(str).fillna('')
        self.df_recettes['Transportable'] = self.df_recettes['Transportable'].astype(str).fillna('')

        # Menus Historique
        if not self.df_menus_historique.empty:
            colonnes_menus_hist_req = ["Date", COLONNE_NOM]
            verifier_colonnes(self.df_menus_historique, colonnes_menus_hist_req, FICHIER_MENUS)
            self.df_menus_historique['Date'] = pd.to_datetime(self.df_menus_historique['Date'], errors='coerce')
            self.df_menus_historique = self.df_menus_historique.dropna(subset=['Date'])
            self.df_menus_historique[COLONNE_NOM] = self.df_menus_historique[COLONNE_NOM].astype(str)
        else:
            logger.info("Historique des menus vide ou non disponible.")

    def _filtrer_recettes_recemment_mangees(self, recettes_potentielles, date_repas_actuelle):
        if self.df_menus_historique.empty:
            return recettes_potentielles

        date_limite = date_repas_actuelle - timedelta(days=NB_JOURS_ANTI_REPETITION)
        recettes_recentes = self.df_menus_historique[
            self.df_menus_historique['Date'] > date_limite
        ][COLONNE_NOM].unique()

        recettes_filtrees = recettes_potentielles[
            ~recettes_potentielles[COLONNE_NOM].isin(recettes_recentes)
        ].copy()
        return recettes_filtrees

    def _filtrer_recettes_preference(self, recettes, preferences_a_exclure):
        if not preferences_a_exclure:
            return recettes

        if COLONNE_AIME_PAS_PRINCIP not in recettes.columns:
            logger.warning(f"La colonne '{COLONNE_AIME_PAS_PRINCIP}' est manquante dans les recettes. Le filtre de préférence ne sera pas appliqué.")
            return recettes

        preferences_set = set(p.strip().lower() for p in preferences_a_exclure if p and p.strip())
        if not preferences_set:
            return recettes

        recettes_filtrees = recettes[
            ~recettes[COLONNE_AIME_PAS_PRINCIP].astype(str).str.lower().apply(
                lambda x: any(pref in x for pref in preferences_set)
            )
        ].copy()
        return recettes_filtrees

    def _filtrer_recettes_par_type(self, recettes, type_repas):
        type_plat_map = {
            "Déjeuner": ["Salade", "Soupe", "Plat"],
            "Dîner": ["Salade", "Soupe", "Plat"]
        }
        types_autorises = type_plat_map.get(type_repas)
        if not types_autorises:
            logger.warning(f"Type de repas '{type_repas}' non reconnu pour le filtrage par type de plat.")
            return recettes.copy()

        if 'Type_plat' not in recettes.columns:
            logger.warning("La colonne 'Type_plat' est manquante dans les recettes. Le filtre par type de plat ne sera pas appliqué.")
            return recettes.copy()

        recettes_filtrees = recettes[
            recettes['Type_plat'].astype(str).apply(
                lambda x: any(tp in x for tp in types_autorises)
            )
        ].copy()
        return recettes_filtrees

    def _evaluer_recettes(self, recettes_candidates, nb_personnes, preferences_a_exclure=[]):
        evaluations = []
        for index, recette in recettes_candidates.iterrows():
            recette_id = str(recette[COLONNE_ID_RECETTE])
            nom_recette = recette[COLONNE_NOM]
            temps_total = recette[COLONNE_TEMPS_TOTAL]
            calories = recette['Calories']
            proteines = recette['Proteines']
            aime_pas = [s.strip().lower() for s in str(recette[COLONNE_AIME_PAS_PRINCIP]).split(',') if s.strip()]
            transportable = recette['Transportable'] == "Oui"

            score_dispo, pourcentage_dispo, ingredients_manquants = self.recette_manager.evaluer_disponibilite_et_manquants(recette_id, nb_personnes)

            score_preference = 1.0
            for pref in preferences_a_exclure:
                if pref.lower() in aime_pas:
                    score_preference = 0.0
                    break

            score_temps = 1.0
            if temps_total > TEMPS_MAX_RAPIDE:
                score_temps = 0.5
            elif temps_total > TEMPS_MAX_EXPRESS:
                score_temps = 0.8

            score_nutri = 1.0
            if REPAS_EQUILIBRE > 0:
                deviation_calories = abs(calories - REPAS_EQUILIBRE) / REPAS_EQUILIBRE
                score_nutri *= (1 - min(deviation_calories, 0.5))

            poids_dispo = 0.4
            poids_preference = 0.2
            poids_temps = 0.2
            poids_nutri = 0.2

            score_final = (score_dispo * poids_dispo +
                           score_preference * poids_preference +
                           score_temps * poids_temps +
                           score_nutri * poids_nutri)

            evaluations.append({
                'recette': recette,
                'score_final': score_final,
                'score_dispo': score_dispo,
                'pourcentage_dispo': pourcentage_dispo,
                'ingredients_manquants': ingredients_manquants,
                'score_preference': score_preference,
                'score_temps': score_temps,
                'score_nutri': score_nutri,
                'transportable': transportable
            })
        return evaluations

    def generer_menu(self, preferences_a_exclure=[]):
        menu_genere = []
        df_planning_sort = self.df_planning.sort_values(by='Date').copy()

        for index, jour in df_planning_sort.iterrows():
            date_repas_actuelle = jour['Date']
            nb_personnes = jour['Participant(s)']
            type_repas = jour['Type de repas']

            logger.info(f"Génération du menu pour le {date_repas_actuelle.strftime('%d/%m/%Y')} - {type_repas} ({nb_personnes} pers.)")

            recettes_candidates = self.df_recettes.copy()

            recettes_candidates = self._filtrer_recettes_recemment_mangees(recettes_candidates, date_repas_actuelle)
            if recettes_candidates.empty:
                logger.warning(f"Aucune recette disponible après le filtre anti-répétition pour {date_repas_actuelle}.")
                # Ajout d'un plat par défaut si aucune recette n'est trouvée
                menu_genere.append(self._ajouter_plat_par_defaut(date_repas_actuelle, type_repas, nb_personnes, "Anti-répétition trop stricte"))
                continue

            recettes_candidates = self._filtrer_recettes_par_type(recettes_candidates, type_repas)
            if recettes_candidates.empty:
                logger.warning(f"Aucune recette disponible après le filtre par type de plat pour {date_repas_actuelle} ({type_repas}).")
                menu_genere.append(self._ajouter_plat_par_defaut(date_repas_actuelle, type_repas, nb_personnes, f"Pas de plat de type {type_repas}"))
                continue

            evaluations = self._evaluer_recettes(recettes_candidates, nb_personnes, preferences_a_exclure)
            if not evaluations:
                logger.warning(f"Aucune recette n'a pu être évaluée pour {date_repas_actuelle}.")
                menu_genere.append(self._ajouter_plat_par_defaut(date_repas_actuelle, type_repas, nb_personnes, "Aucune recette évaluée"))
                continue

            evaluations_triees = sorted(evaluations, key=lambda x: x['score_final'], reverse=True)

            recette_choisie = None
            for eval_recette in evaluations_triees:
                recette = eval_recette['recette']
                score_final = eval_recette['score_final']
                score_dispo = eval_recette['score_dispo']
                pourcentage_dispo = eval_recette['pourcentage_dispo']
                ingredients_manquants = eval_recette['ingredients_manquants']

                logger.info(f"  Recette candidate: {recette[COLONNE_NOM]} (Score: {score_final:.2f}, Dispo: {pourcentage_dispo:.1f}%)")

                if score_dispo > 0 and score_final > 0.4:
                    recette_choisie = recette
                    self.recette_manager.ajuster_stock_simule(str(recette_choisie[COLONNE_ID_RECETTE]), nb_personnes)
                    logger.info(f"✅ Recette sélectionnée : {recette_choisie[COLONNE_NOM]} (Score final: {score_final:.2f})")
                    break
                else:
                    logger.debug(f"  Recette {recette[COLONNE_NOM]} rejetée (Dispo: {pourcentage_dispo:.1f}%, Score: {score_final:.2f}).")


            if recette_choisie is None:
                logger.warning(f"Impossible de trouver une recette adaptée pour {date_repas_actuelle.strftime('%d/%m/%Y')} - {type_repas}. Ajout d'un repas 'Plat à définir'.")
                menu_genere.append(self._ajouter_plat_par_defaut(date_repas_actuelle, type_repas, nb_personnes, "Aucune recette satisfaisante"))
            else:
                menu_genere.append({
                    'Date': date_repas_actuelle.strftime('%d/%m/%Y'),
                    'Jour': date_repas_actuelle.strftime('%A'),
                    'Type de repas': type_repas,
                    'Participant(s)': nb_personnes,
                    'Nom': recette_choisie[COLONNE_NOM],
                    'ID_Recette': recette_choisie[COLonne_ID_RECETTE],
                    'Temps_total': recette_choisie[COLONNE_TEMPS_TOTAL],
                    'Calories': recette_choisie['Calories'],
                    'Proteines': recette_choisie['Proteines'],
                    'Aime_pas_princip': recette_choisie[COLONNE_AIME_PAS_PRINCIP],
                    'Transportable': recette_choisie['Transportable']
                })
        return pd.DataFrame(menu_genere)

    def _ajouter_plat_par_defaut(self, date_repas, type_repas, nb_personnes, raison=""):
        return {
            'Date': date_repas.strftime('%d/%m/%Y'),
            'Jour': date_repas.strftime('%A'),
            'Type de repas': type_repas,
            'Participant(s)': nb_personnes,
            'Nom': f'Plat à définir ({raison})' if raison else 'Plat à définir',
            'ID_Recette': 'N/A',
            'Temps_total': 0,
            'Calories': 0,
            'Proteines': 0,
            'Aime_pas_princip': '',
            'Transportable': ''
        }

# --- Exécution principale ---
if __name__ == "__main__":
    logger.info("Démarrage du script de génération de menus.")

    try:
        # df_planning est déjà chargé au début du script
        df_recettes = pd.read_csv(FICHIER_RECETTES, encoding='utf-8')
        df_menus = pd.read_csv(FICHIER_MENUS, encoding='utf-8')
        df_ingredients = pd.read_csv(FICHIER_INGREDIENTS, encoding='utf-8')
        df_ingredients_recettes = pd.read_csv(FICHIER_INGREDIENTS_RECETTES, encoding='utf-8')

        logger.info(f"Fichiers chargés : {planning_file_name}, {FICHIER_RECETTES}, {FICHIER_MENUS}, {FICHIER_INGREDIENTS}, {FICHIER_INGREDIENTS_RECETTES}")
        logger.info(f"Planning head:\n{df_planning.head()}")
        logger.info(f"Recettes head:\n{df_recettes.head()}")
        logger.info(f"Menus historique head:\n{df_menus.head()}")
        logger.info(f"Ingrédients head:\n{df_ingredients.head()}")
        logger.info(f"Ingrédients recettes head:\n{df_ingredients_recettes.head()}")

    except FileNotFoundError as e:
        logger.critical(f"Erreur: Fichier de données manquant : {e}. Assurez-vous que tous les CSV sont présents et nommés correctement.")
        exit()
    except pd.errors.EmptyDataError as e:
        logger.critical(f"Erreur: Le fichier est vide : {e}. Veuillez vérifier son contenu.")
        exit()
    except Exception as e:
        logger.critical(f"Erreur lors du chargement des fichiers : {e}")
        exit()

    recette_manager = RecetteManager(df_recettes, df_ingredients, df_ingredients_recettes)

    menu_generator = MenuGenerator(df_planning, df_recettes, df_menus, recette_manager)

    preferences_a_exclure = ["lentilles", "chèvre"]

    df_menu_genere = menu_generator.generer_menu(preferences_a_exclure)

    if not df_menu_genere.empty:
        df_menu_genere[COLONNE_NOM] = df_menu_genere[COLONNE_NOM].astype(str).apply(
            lambda x: unicodedata.normalize('NFKC', x).title()
        )
        df_menu_genere.loc[df_menu_genere['Nom'].str.startswith('Plat À Définir'), 'ID_Recette'] = ''

        logger.info("Génération du récapitulatif des ingrédients et de la liste de courses.")
        liste_courses, ingredients_par_repas = recette_manager.generer_liste_courses(df_menu_genere, df_planning)

        contenu_fichier_recap_txt = []

        contenu_fichier_recap_txt.append("=== Récapitulatif des ingrédients par repas ===\n")
        dates_triees = sorted(ingredients_par_repas.keys(), key=lambda x: datetime.strptime(x, '%d/%m/%Y'))

        for date_repas in dates_triees:
            contenu_fichier_recap_txt.append(f"\n--- Le {date_repas} ---\n")
            for nom_repas, ingredients_details in ingredients_par_repas[date_repas].items():
                contenu_fichier_recap_txt.append(f"  Repas: {nom_repas}\n")
                for ing_detail in ingredients_details:
                    contenu_fichier_recap_txt.append(
                        f"    - {ing_detail['nom']} : Nécessaire {ing_detail['qte_necessaire']:.2f} {ing_detail['unite']} "
                        f"(Stock: {ing_detail['qte_en_stock']:.2f}, A acheter: {ing_detail['qte_achetee']:.2f})\n"
                    )

        contenu_fichier_recap_txt.append("\n=== LISTE DE COURSES FINALE ===\n")
        if liste_courses:
            ingredients_trier = sorted(
                liste_courses.items(),
                key=lambda item: (item[1]["type_stock"], item[0].lower())
            )
            current_type_stock = None
            for nom_ing, details in ingredients_trier:
                if details["type_stock"] != current_type_stock:
                    current_type_stock = details["type_stock"]
                    contenu_fichier_recap_txt.append(f"\n--- {current_type_stock.upper()} ---\n")
                contenu_fichier_recap_txt.append(f"- {nom_ing}: {details['quantite']:.2f} {details['unite']}\n")
        else:
            contenu_fichier_recap_txt.append("Aucun ingrédient à acheter pour ce menu.\n")

        contenu_fichier_recap_txt.append("\n=== INGRÉDIENTS À CONSOMMER EN PRIORITÉ (Anti-Gaspi) ===\n")
        if recette_manager.anti_gaspi_ingredients:
            for ing_id, ing_nom in recette_manager.anti_gaspi_ingredients.items():
                ing_stock_df = recette_manager.stock_simule[recette_manager.stock_simule[COLONNE_ID_INGREDIENT].astype(str) == ing_id]
                if not ing_stock_df.empty:
                    qte_stock_anti_gaspi = ing_stock_df["Qte reste"].iloc[0]
                    unite_anti_gaspi = ing_stock_df["unité"].iloc[0]
                    contenu_fichier_recap_txt.append(f"- {ing_nom} ({qte_stock_anti_gaspi:.2f} {unite_anti_gaspi})\n")
                else:
                    contenu_fichier_recap_txt.append(f"- {ing_nom} (Quantité non trouvée)\n")
        else:
            contenu_fichier_recap_txt.append("Aucun ingrédient en stock élevé à consommer en priorité.\n")

        # Sauvegarde des fichiers
        df_menu_genere.columns = df_menu_genere.columns.str.replace("[^a-zA-Z0-9_]", "", regex=True)

        if not df_menu_genere.empty:
            logger.info(f"Nombre de lignes totales générées : {len(df_menu_genere)}")
            if 'Date' in df_menu_genere.columns:
                df_menu_genere['Date'] = pd.to_datetime(df_menu_genere['Date'], format="%d/%m/%Y", errors='coerce').dt.strftime('%Y-%m-%d %H:%M')
            colonnes_export = ["Date", "Participants", "Nom"]
            # Vérifier si les colonnes existent avant d'exporter
            colonnes_export_existantes = [col for col in colonnes_export if col in df_menu_genere.columns]
            df_menu_genere.to_csv(FICHIER_SORTIE_MENU_CSV, columns=colonnes_export_existantes, index=False, encoding="utf-8-sig")
            logger.info(f"Fichier CSV enregistré sous '{FICHIER_SORTIE_MENU_CSV}'")
        else:
            logger.warning(f"DataFrame menu vide. '{FICHIER_SORTIE_MENU_CSV}' non créé.")

        try:
            with open(FICHIER_SORTIE_LISTES_TXT, "w", encoding="utf-8") as f_txt:
                f_txt.writelines(contenu_fichier_recap_txt)
            logger.info(f"Récapitulatif des ingrédients enregistré dans '{FICHIER_SORTIE_LISTES_TXT}'")
        except Exception as e:
            logger.error(f"Erreur écriture récapitulatif des ingrédients: {e}")

        print("\n=== Génération du menu terminée ===\n")
        print(f"Les fichiers '{FICHIER_SORTIE_MENU_CSV}' et '{FICHIER_SORTIE_LISTES_TXT}' ont été créés.")
        print("\nContenu de Menu_genere.csv (premières lignes) :")
        print(df_menu_genere.head())
        print("\nContenu de recapitulatif_ingredients.txt (extrait) :")
        print("".join(contenu_fichier_recap_txt[:20])) # Afficher les 20 premières lignes

    else:
        print("Aucun menu n'a pu être généré. Veuillez vérifier vos données de planning et de recettes.")
